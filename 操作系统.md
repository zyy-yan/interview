###操作系统

####1、进程和线程以及它们的区别

- 进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；
- 线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的 实时性，实现进程内部的并发；
- 一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；
- 进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。

####2、进程间的通信的几种方式

- 管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
- 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
- 消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；
- 共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；
- 信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；
- 套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。

------

####3、线程同步的方式

- 互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
- 信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
- 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

------

####4、什么是死锁？死锁产生的条件？

1). 死锁的概念

　　在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。

------

2). 死锁产生的四个必要条件

- 互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；
- 占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；
- 非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放
- 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系

------

####5、进程有哪几种状态？

- 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；

- 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数；

- 阻塞状态： 进程等待某种条件，在条件满足之前无法执行

- ![undefined](http://ww1.sinaimg.cn/large/0062FU9hly1ghjr0h1vj9j30ay06z3ym.jpg)

  

####6、线程有几种状态？**

　　在 Java虚拟机 中，线程从最初的创建到最终的消亡，要经历若干个状态：创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。在给定的时间点上，一个线程只能处于一种状态，各状态的含义如下图所示：

![undefined](http://ww1.sinaimg.cn/large/0062FU9hly1ghjr139ptsj30lm0erwfv.jpg)

####7、线程安全发生的原因（共享内存）

在多个线程并发的情况下，多个线程共同访问同一共享内存资源时，其中一个线程对资源进行写操作的中途（写入已开始，但还没结束），其他线程对这个写了一半的资源进行了读/写操作，导致资源出现数据错误

####8、如何避免线程安全问题

保证共享资源在同一时间只能由一个线程进行操作（原子性：互斥锁；有序性：线程等待）

将线程操作结果及时刷新，保证其他线程可以立即获取到修改后的最新数据（可见性）

####9、分页和分段有什么区别（内存管理）？

　　段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）

　　页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。

**两者的不同点：**

- 目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；
- 大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；
- 地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；
- 信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；
- 内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。

####10、操作系统中进程调度策略有哪几种？

- FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU
- SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度
- 优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：**老化**
- 时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。
- 多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。
- 多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。

####11、说一说进程同步有哪几种机制

　　原子操作、信号量机制、自旋锁管程、会合、分布式系统

------

####12、什么是虚拟内存？

**虚拟内存**

　　虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，**对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上，如图5所示。**
注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。

![undefined](http://ww1.sinaimg.cn/large/0062FU9hly1ghkaeb383kj309r0bg3ys.jpg)

由图5可以看出，虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如图5的0，1，2）。如果虚拟内存的页并不存在于物理内存中（如图5的3,4），会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。

------

**页面置换算法**

- FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；
- LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断；
- LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；
- OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。

------

**虚拟内存的应用与优点**

　　虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。虚拟内存的使用可以带来以下好处：

- 在内存中可以保留多个进程，系统并发度提高
- 解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大

#### 13、linux命令

- **iostat -x 磁盘使用**

- **free命令。**查看内存使用多少。常用free -h

- **swap**;现时可用的交换内存（k表示）

- **ps命令。**ps查看系统进程。ps命令经常会连同管道符一起使用，用来查看某个进程或者它的数量

  **ps-aux或ps-elf.查看当前系统都有哪些进程**

- **netstat 查看网络状况。**netstat命令用来打印网络连接状况、系统所开放端口、路由表等信息。

  1、netstat -lnp 打印当前系统启动哪些端口

  2、netstat -an 打印网络连接状况

- **linux抓包工具tcpdump**
  有时候想看一下某个网卡上都有哪些数据包，尤其是当你初步判定你的服务器上有流量攻击。这时，使用抓包工具来抓一下数据包，就可以知道有哪些IP在攻击你了

- **top命令**。实时显示系统中各个进程的资源占用状况。

  0.1%us：用户态进程占用CPU时间百分比
  0.2%sy：内核占用CPU时间百分比
  0.2%ni：renice值为负的任务的用户态进程的CPU时间百分比。nice是优先级的意思
  99.4%id：空闲CPU时间百分比
  0.0%wa：等待I/O的CPU时间百分比
  0.0%hi：CPU硬中断时间百分比
  0.0%si：CPU软中断时间百分比

- **vmstat 是用来实时查看内存使用情况,反映的情况比用top直观一些.**

  r即running，表示正在跑的任务数

  b即blocked，表示被阻塞的任务数

  si表示有多少数据从交换分区读入内存

  so表示有多少数据从内存写入交换分区

  bi表示有多少数据从磁盘读入内存

  bo表示有多少数据从内存写入磁盘

- **ipcs -m　　查看系统共享内存信息**

  　　ipcs -q　　查看系统消息队列信息

  　　ipcs -s　　查看系统信号量信息

  　　ipcs [-a]　系统默认输出信息，显示系统内所有的IPC信息

- **ipcs -a命令**可以查看当前使用的共享内存、消息队列及信号量所有信息

- **ipcs -p命令可以得到与共享内存、消息队列相关进程之间的消息**。消息队列id，根据id则可以获取到lspid、lrpid消息，其中lspid代表最近一次向消息队列中发送消息的“进程号”，lrpid对应最近一次从消息队列中读取消息的“进程号”

- **ipcs -u命令可以查看各个资源的使用总结信息，**其中可以看到使用的信号量集的个数、信号量的个数，以及消息队列中当前使用的消息个数总数、占用的空间字节数。

- **ipcs -l命令可以查看各个资源的系统限制信息，**可以看到系统允许的最大信号量集及信号量个数限制、最大的消息队列中消息个数等信息。

- **ipcrm命令。删除消息队列、共享内存、信号灯**

  -M   以shmkey删除共享内存

  -m   以shmid删除共享内存

  -Q   以msgkey删除消息队列

  -q    以msgid删除消息队列

  -S    以semkey删除信号灯

  -s    以semid删除信号灯

- **disk 显示每秒的磁盘操作。** 

- **df命令。df查看文件系统中磁盘的使用情况。**硬盘已用和可用的存储空间以及其他存储设备。
- grep**命令可以**指定文件中搜索特定的内容，并将含有这些内容的行标准输出。

**系统信息：**

uname -a               # 查看内核/操作系统/CPU信息
head -n 1 /etc/issue   # 查看操作系统版本
cat /proc/cpuinfo      # 查看CPU信息
hostname               # 查看计算机名
lspci -tv              # 列出所有PCI设备
lsusb -tv              # 列出所有USB设备
lsmod                  # 列出加载的内核模块
env                    # 查看环境变量

**资源：**

free -m                # 查看内存使用量和交换区使用量
df -h                  # 查看各分区使用情况
du -sh <目录名>        # 查看指定目录的大小
grep MemTotal /proc/meminfo   # 查看内存总量
grep MemFree /proc/meminfo    # 查看空闲内存量
uptime                 # 查看系统运行时间、用户数、负载
cat /proc/loadavg      # 查看系统负载

