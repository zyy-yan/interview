###操作系统

####1、进程和线程以及它们的区别

#####基本概念：

- 进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；

- 线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。

#####区别：

1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。

2.**进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。**（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）

3.进程是资源分配的最小单位，线程是CPU调度的最小单位；

4.系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，**进程切换的开销也远大于线程切换的开销。**

5.通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预

6.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。

7.进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉

8.进程适应于多核、多机分布；线程适用于多核

#####linux理解：

从资源的角度来看
通俗的来讲无非是，计算资源，存储资源
进程可以说是操作系统分配存储资源的最小单元，
线程则是操作系统分配计算资源的最小单元，它可以独立调度
但是线程无法独立运行，它必须从属于某一进程，共享进程的存储资源，才能运行
进程占有了大量的存储资源，所以导致进程的创建和切换开销很大
线程只占有了少量的存储资源，所以创建和切换的开销小
从属于一个进程的所有线程，共享进程拥有的资源，所以它们之间可以方便的进行通信
理论上说Linux内核是没有线程这个概念的，只有内核调度实体(Kernal Scheduling Entry， KSE)这个概念。Linux的线程本质上是一种轻量级的进程，是通过clone系统调用来创建的。它提供了一系列的参数来表示线程可以共享父类的哪些资源，比如页表，打开文件表等等。共享只是简单地用指针指向同一个物理地址，不会在父进程之外开辟新的物理内存。所以创建线程开销比创建进程开销小

####2、进程间的通信的几种方式

- 管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
- 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
- 消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；
- 共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；
- 信号量：它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。
- 套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。

------

#### 3、为什么说共享内存是最有效的进程间通信方式？

使用管道(FIFO/消息队列)从一个文件传输信息到另外一个文件需要复制4次。一是，服务器端将信息从相应的文件复制到server临时缓冲区中；二是，从临时缓冲区中复制到管道（FIFO/消息队列）；三是，客户端将信息从管道（FIFO/消息队列）复制到client端的缓冲区中；四是，从client临时缓冲区将信息复制到输出文件中。

而使用共享内存的话，进程可以直接读写内存，而不需要任何数据的拷贝。从输入文件到共享内存；从共享内存到输出文件。这样就很大程度上提高了数据存取的效率。

它将同一块内存区域映射到共享它的不同进程的地址空间中，使得这些进程间的通信就不需要再经过内核，只需对该共享的内存区域进程操作就可以了，但是它需要用户自己进行同步操作。

------

####3、线程同步的方式

##### 临界区：

- 通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；

##### 互斥量Synchronized/Lock：

- 采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：

- pthread_mutex_init:初始化互斥锁

- pthread_mutex_destroy：销毁互斥锁

- pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。

- pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁。

##### 信号量Semphare：

- 为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。其有关的系统调用为：

- sem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。

- sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。

#####条件变量：

- 条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用 signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：

- pthread_cond_init:初始化条件变量

- pthread_cond_destroy：销毁条件变量

- pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。

- pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。

------

#### 4、协程

##### 1、概念

协程，又称微线程。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。

#####2、协程和线程区别

那和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。

第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

#####3、其他

在协程上利用多核CPU呢——多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。



------

####4、进程有哪几种状态？

- 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；

- 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数；

- 阻塞状态： 进程等待某种条件，在条件满足之前无法执行

- ![undefined](http://ww1.sinaimg.cn/large/0062FU9hly1ghjr0h1vj9j30ay06z3ym.jpg)

  

####5、线程有几种状态？

　　在 Java虚拟机 中，线程从最初的创建到最终的消亡，要经历若干个状态：创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。在给定的时间点上，一个线程只能处于一种状态，各状态的含义如下图所示：

![undefined](http://ww1.sinaimg.cn/large/0062FU9hly1ghjr139ptsj30lm0erwfv.jpg)

####6、线程安全发生的原因（共享内存）

在多个线程并发的情况下，多个线程共同访问同一共享内存资源时，其中一个线程对资源进行写操作的中途（写入已开始，但还没结束），其他线程对这个写了一半的资源进行了读/写操作，导致资源出现数据错误

####7、如何避免线程安全问题

保证共享资源在同一时间只能由一个线程进行操作（原子性：互斥锁；有序性：线程等待）

将线程操作结果及时刷新，保证其他线程可以立即获取到修改后的最新数据（可见性）

#### 8、什么是死锁？死锁产生的条件？

1). 死锁的概念

　　在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。

------

2). 死锁产生的四个必要条件

- 互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；
- 占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；
- 非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放
- 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系

####9、互斥锁（mutex）机制，以及互斥锁和读写锁的区别

#####1、互斥锁和读写锁区别：

互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。

读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。

互斥锁和读写锁的区别：

1）读写锁区分读者和写者，而互斥锁不区分

2）互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。

#####2、Linux的4种锁机制：

互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒

读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。

自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。

RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。

####9、分页和分段有什么区别（内存管理）？

　　段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）

　　页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。

**两者的不同点：**

- 目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；
- 大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；
- 地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；
- 信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；
- 内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。

####10、操作系统中进程调度策略有哪几种？

- FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU
- SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度
- 优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：**老化**
- 时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。
- 多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。
- 多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。

####11、说一说进程同步有哪几种机制

　　原子操作、信号量机制、自旋锁管程、会合、分布式系统

------

####12、什么是虚拟内存？

#####虚拟内存

　　虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，**对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上，如图5所示。**
注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。

![undefined](http://ww1.sinaimg.cn/large/0062FU9hly1ghkaeb383kj309r0bg3ys.jpg)

由图5可以看出，虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如图5的0，1，2）。如果虚拟内存的页并不存在于物理内存中（如图5的3,4），会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。

------

#####页面置换算法

- FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；
- LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断；
- LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；
- OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。

------

#####虚拟内存好处

- 扩大地址空间；
- 内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。

- 公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。

- 当进程通信时，可采用虚存共享的方式实现。

- 当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存

- 虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高

- 在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片

- 在内存中可以保留多个进程，系统并发度提高
- 解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大

#####虚拟内存的代价：

- 虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存

- 虚拟地址到物理地址的转换，增加了指令的执行时间。

- 页面的换入换出需要磁盘I/O，这是很耗时的

- 如果一页中只有一部分数据，会浪费内存。

#### 13、linux命令

- **iostat -x 磁盘使用**

- **free命令。**查看内存使用多少。常用free -h

- **swap**;现时可用的交换内存（k表示）

- **ps命令。**ps查看系统进程。ps命令经常会连同管道符一起使用，用来查看某个进程或者它的数量

  **ps-aux或ps-elf.查看当前系统都有哪些进程**

- **netstat 查看网络状况。**netstat命令用来打印网络连接状况、系统所开放端口、路由表等信息。

  1、netstat -lnp 打印当前系统启动哪些端口

  2、netstat -an 打印网络连接状况

- **linux抓包工具tcpdump**
  有时候想看一下某个网卡上都有哪些数据包，尤其是当你初步判定你的服务器上有流量攻击。这时，使用抓包工具来抓一下数据包，就可以知道有哪些IP在攻击你了

- **top命令**。实时显示系统中各个进程的资源占用状况。

  0.1%us：用户态进程占用CPU时间百分比
  0.2%sy：内核占用CPU时间百分比
  0.2%ni：renice值为负的任务的用户态进程的CPU时间百分比。nice是优先级的意思
  99.4%id：空闲CPU时间百分比
  0.0%wa：等待I/O的CPU时间百分比
  0.0%hi：CPU硬中断时间百分比
  0.0%si：CPU软中断时间百分比

- **vmstat 是用来实时查看内存使用情况,反映的情况比用top直观一些.**

  r即running，表示正在跑的任务数

  b即blocked，表示被阻塞的任务数

  si表示有多少数据从交换分区读入内存

  so表示有多少数据从内存写入交换分区

  bi表示有多少数据从磁盘读入内存

  bo表示有多少数据从内存写入磁盘

- **ipcs -m　　查看系统共享内存信息**

  　　ipcs -q　　查看系统消息队列信息

    　　ipcs -s　　查看系统信号量信息

    　　ipcs [-a]　系统默认输出信息，显示系统内所有的IPC信息

- **ipcs -a命令**可以查看当前使用的共享内存、消息队列及信号量所有信息

- **ipcs -p命令可以得到与共享内存、消息队列相关进程之间的消息**。消息队列id，根据id则可以获取到lspid、lrpid消息，其中lspid代表最近一次向消息队列中发送消息的“进程号”，lrpid对应最近一次从消息队列中读取消息的“进程号”

- **ipcs -u命令可以查看各个资源的使用总结信息，**其中可以看到使用的信号量集的个数、信号量的个数，以及消息队列中当前使用的消息个数总数、占用的空间字节数。

- **ipcs -l命令可以查看各个资源的系统限制信息，**可以看到系统允许的最大信号量集及信号量个数限制、最大的消息队列中消息个数等信息。

- **ipcrm命令。删除消息队列、共享内存、信号灯**

  -M   以shmkey删除共享内存

  -m   以shmid删除共享内存

  -Q   以msgkey删除消息队列

  -q    以msgid删除消息队列

  -S    以semkey删除信号灯

  -s    以semid删除信号灯

- **disk 显示每秒的磁盘操作。** 

- **df命令。df查看文件系统中磁盘的使用情况。**硬盘已用和可用的存储空间以及其他存储设备。
- grep**命令可以**指定文件中搜索特定的内容，并将含有这些内容的行标准输出。

**系统信息：**

uname -a               # 查看内核/操作系统/CPU信息
head -n 1 /etc/issue   # 查看操作系统版本
cat /proc/cpuinfo      # 查看CPU信息
hostname               # 查看计算机名
lspci -tv              # 列出所有PCI设备
lsusb -tv              # 列出所有USB设备
lsmod                  # 列出加载的内核模块
env                    # 查看环境变量

**资源：**

free -m                # 查看内存使用量和交换区使用量
df -h                  # 查看各分区使用情况
du -sh <目录名>        # 查看指定目录的大小
grep MemTotal /proc/meminfo   # 查看内存总量
grep MemFree /proc/meminfo    # 查看空闲内存量
uptime                 # 查看系统运行时间、用户数、负载
cat /proc/loadavg      # 查看系统负载

