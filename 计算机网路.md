###计算机网路

####1、Http和Https的区别

Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：

- 端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；
- 资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；
- 开销：Https通信需要证书，而证书一般需要向认证机构购买；

Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。

HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密。

安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。

HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

Http与Https使用不同的连接方式，用的端口也不一样，前者是80，后者是443；

客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。

　　（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。

　　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。

　　（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。

　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。

　　（5）Web服务器利用自己的私钥解密出会话密钥。

　　（6）Web服务器利用会话密钥加密与客户端之间的通信。

####2、对称加密与非对称加密

　　对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

　　由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。

####3、三次握手与四次挥手

　(1). 三次握手(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)：

- 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
- 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
- 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

![undefined](http://ww1.sinaimg.cn/large/0062FU9hly1ghjiz4777yj30ef073dfw.jpg)

(2). 四次挥手(我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧)：

- 第一次挥手：Client发送一个FIN，**用来关闭Client到Server的数据传送**，Client进入FIN_WAIT_1状态。
- 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
- 第三次挥手：Server发送一个FIN，**用来关闭Server到Client的数据传送**，Server进入LAST_ACK状态。
- 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

![undefined](http://ww1.sinaimg.cn/large/0062FU9hly1ghjjjw0wy7j30e308hmx8.jpg)

####4、为什么TCP链接需要三次握手，两次不可以么，为什么？

1、三次握手主要是为了防止已失效的连接请求报文又传送到服务器端，造成服务器的等待和资源的浪费。

如果采用两次握手，客户端向服务器发送请求，服务器没有对客户的请求进行确认(因为网络延迟他可能没有收到这个请求)。客户端得不到这个确认，过一段时间又向服务器发送了连接请求，并顺利完成了数据传输。但是过了一段时间原来的请求到达了服务器，而服务器误以为这是一个新的连接请求，于是对这个请求进行确认，并发送给客户端，但是客户端没有发起连接请求，因此不会理会服务器的确认，服务器则会一直等待客户发送数据，这样就会造成服务器的资源浪费。

如果采用两次握手，比如：客户端向服务器发送请求A，由于网络延迟服务器可能没有收到这个请求A，客户端得不到这个确认，过了一段时间又重新发送了一个请求B，并且顺利完成了数据传输。但是过了一段时间先前由于网络延迟的请求A这时候到达了服务器，而服务器以为这是一个新的连接请求，于是对这个请求A进行确认，发送给客户端确认请求，但是客户端没有发起连接请求，一次不会理会服务器的确认请求，服务器则会一直等待客户端发送数据，这样就会造成资源的浪费。

2、实现可靠的数据传输

- 为了实现可靠数据传输，TCP协议的通信双方都必须维护一个序列号，以标识发出去的数据包中，哪些是已经被对方接收的。三次握手的过程正是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的步骤
- 如果只是两次握手，至多连接发起方的起始序列号能被确认，另一方选择的序列号得不到确认。

####5、为什么要有TIME_WAIT这个状态？

​    假设最终的ACK丢失，主机2将重发FIN，主机1必须维护TCP状态信息以便可以重发最终的ACK，否则会发送RST，结果主机2认为发生错误。TCP实现必须可靠地终止连接的两个方向(全双工关闭)，主机1必须进入 TIME_WAIT 状态，因为主机1可能面 临重发最终ACK的情形。

TCP 协议需要 `TIME_WAIT` 状态的原因和客户端需要等待两个 MSL 不能直接进入 `CLOSED` 状态的原因是一样的：

- 防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到；
- 保证 TCP 连接的远程被正确关闭，即等待被动关闭连接的一方收到 `FIN` 对应的 `ACK` 消息；

####6、**出现太多TIME_WAIT可能导致的后果：**

​    在高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接。这个场景下，会出现大量socket处于TIMEWAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。主动正常关闭TCP连接，都会出现TIMEWAIT。**持续的到达一定量的高并发短连接，会使服务器因端口资源不足而拒绝为一部分客户服务。**

####7、TCP协议如何来保证传输的可靠性

**对于可靠性，TCP通过以下方式进行保证：**

- 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；
- 对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；
- 丢弃重复数据：对于重复数据，能够丢弃重复数据；
- 应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
- 超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
- 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

####8、Get与POST的区别

　　GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面：

- 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；
- 从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；
- 从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以?分割URL和传输数据，参数之间以&相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 请求体 中。
- 就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。
- 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。

####9、TCP与UDP的区别

TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：

- TCP是面向连接的，UDP是无连接的；
- TCP是可靠的，UDP是不可靠的；
- TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；
- TCP是面向字节流的，UDP是面向报文的；
- TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；
- TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；

TCP和UDP的区别

TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。

UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。

TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。

TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。

此外，

UDP 常用于一下几个方面：1.包总量较少的通信（DNS、SNMP等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）

#### 10、流量控制和拥塞控制

什么是流量控制？流量控制的目的？

如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。

流量控制是由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。

#####区别

拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。

流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。

#####拥塞控制的算法

假定：1、数据是单方向传递，另一个窗口只发送确认；2、接收方的缓存足够大，因此发送方的大小的大小由网络的拥塞程度来决定。

- **慢开始算法**

发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。

慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。每经历一个往返RTT时间，拥塞窗口大小加倍，按指数规律增长。

**为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：当cwnd<ssthresh时，使用慢开始算法。**
**当cwnd>ssthresh时，改用拥塞避免算法。**
**当cwnd=ssthresh时，慢开始与拥塞避免算法任意**

- **拥塞避免算法**

拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。

**无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半，并执行慢开始算法，所以当网络频繁出现拥塞时，ssthresh下降的很快，以大大减少注入到网络中的分组数。**

- **快重传算法**

快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

- **快恢复算法**

快重传配合使用的还有快恢复算法，有以下两个要点：

当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞）。但是接下去并不执行慢开始算法
考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大。

####11、从输入网址到获得页面的过程

- **1、域名解析，其实就是根据用户输入的网址去寻找它对应的IP地址，比如输入www.baidu.com的网址就会经历以下过程**

  1.先从浏览器缓存里找IP,因为浏览器会缓存DNS记录一段时间

  2.如没找到,再从Hosts文件查找是否有该域名和对应IP

  3.如没找到,再从路由器缓存找

  4.如没好到,再从DNS缓存查找

  5.如果都没找到,浏览器域名服务器向根域名服务器(baidu.com)查找域名对应IP,还没找到就把请求转发到下一级,直到找到IP

- **2、建立TCP连接 （这里使用五层协议更详细的描述如何建立这个TCP链接的）**

  先是客户端发起请求过程：
  1. 使用应用层发起HTTP请求（这个可以根据你本身输入的url访问时，用的什么协议就发起对应协议去进行请求）
  2. 然后是传输层的TCP协议为传输报文提供可靠的字节流服务，这里也就使用了TCP三次握手
  3. 网络层是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址
  4. 然后才是链路层将数据发送到数据链路层传输。至此请求报文已发出，客户端发送请求的阶段结束

  **然后是服务端接受请求处理阶段：**
  原路进行处理：**链路层—>网络层—>传输层—>应用层**然后响应客户端发送报文。

- **3、根据SpringMVC后台业务返回数据，并把数据填充到HTML页面上，然后返回给浏览器**

- **4、浏览器进行处理**
  服务器通过后台语言程序处理,找到数据返回给浏览器,HTML字符串被浏览器接受后被一句句读取解析,解析到link标签后重新发送请求获取css,解析到sript标签后发送请求获取js,并执行代码

- **5、绘制网页**
  然后浏览器会进行渲染，浏览器根据HTML和CSS计算得到渲染树,绘制到屏幕上,js会被执行

####12、OSI网络体系结构与TCP/IP协议模型

我们知道TCP/IP与OSI最大的不同在于：OSI是一个理论上的网络通信模型，而TCP/IP则是实际上的网络通信标准。但是，它们的初衷是一样的，都是为了使得两台计算机能够像两个知心朋友那样能够互相准确理解对方的意思并做出优雅的回应。

![undefined](http://ww1.sinaimg.cn/large/0062FU9hly1ghjnqo9eiyj30g70agab7.jpg)

- 物理层

  参考模型的最低层，也是OSI模型的第一层，实现了相邻计算机节点之间比特流的透明传送，并尽可能地屏蔽掉具体传输介质和物理设备的差异，使其上层(数据链路层)不必关心网络的具体传输介质。

- 数据链路层（data link layer）

  接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。

- 网络层

  将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。

- 传输层（transport layer）

  在源端与目的端之间提供可靠的透明数据传输，使上层服务用户不必关系通信子网的实现细节。在协议栈中，传输层位于网络层之上，传输层协议为不同主机上运行的进程提供逻辑通信，而网络层协议为不同主机提供逻辑通信。

- 会话层（Session Layer）

  会话层是OSI模型的第五层，是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信。

- 表示层（Presentation Layer）：数据的编码，压缩和解压缩，数据的加密和解密

  表示层是OSI模型的第六层，它对来自应用层的命令和数据进行解释，以确保一个系统的应用层所发送的信息

- 应用层（Application layer）：为用户的应用进程提供网络通信服务

####13、TCP和UDP分别对应的常见应用层协议

1). TCP对应的应用层协议

- FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。
- Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。
- SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。
- POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。
- HTTP：从Web服务器传输超文本到本地浏览器的传送协议。

2). UDP对应的应用层协议

- DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
- SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
- TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。

####14、 常见状态码及原因短语

　　HTTP请求结构： 请求方式 + 请求URI + 协议及其版本
　　HTTP响应结构： 状态码 + 原因短语 + 协议及其版本

------

- **1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码。代码 说明**

  100 (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。

  101 (切换协议) 请求者已要求服务器切换协议，服务器已确认并准备切换。

------

- **2xx (成功)表示成功处理了请求的状态代码。代码 说明**

  200 (成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。

  201 (已创建) 请求成功并且服务器创建了新的资源。

  202 (已接受) 服务器已接受请求，但尚未处理。

  203 (非授权信息) 服务器已成功处理了请求，但返回的信息可能来自另一来源。

  204 (无内容) 服务器成功处理了请求，但没有返回任何内容。

  205 (重置内容) 服务器成功处理了请求，但没有返回任何内容。

  206 (部分内容) 服务器成功处理了部分 GET 请求。

------

- **3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。代码 说明**

  300 (多种选择) 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。

  301 (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。

  302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

  303 (查看其他位置) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。

  304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。

  305 (使用代理) 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。

  307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

------

- **4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理。代码 说明**

  400 (错误请求) 服务器不理解请求的语法。

  401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。

  403 (禁止) 服务器拒绝请求。

  404 (未找到) 服务器找不到请求的网页。

  405 (方法禁用) 禁用请求中指定的方法。

  406 (不接受) 无法使用请求的内容特性响应请求的网页。

  407 (需要代理授权) 此状态代码与 401(未授权)类似，但指定请求者应当授权使用代理。

  408 (请求超时) 服务器等候请求时发生超时。

  409 (冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。

  410 (已删除) 如果请求的资源已永久删除，服务器就会返回此响应。

  411 (需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。

  412 (未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。

  413 (请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。

  414 (请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法处理。

  415 (不支持的媒体类型) 请求的格式不受请求页面的支持。

  416 (请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。

  417 (未满足期望值) 服务器未满足"期望"请求标头字段的要求。

------

- **5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。代码 说明**

  500 (服务器内部错误) 服务器遇到错误，无法完成请求。

  501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。

  502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。

  503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。

  504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。

  505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。



#####简单介绍状态码：

1开头的表示临时响应并需要请求者继续执行操作的状态代码

比如101是请求者已要求服务器切换协议，服务器已经确认并准备切换

2开头的表示成功处理了请求的状态码

比如201 (已创建) 请求成功并且服务器创建了新的资源。

3开头的表示重定向

304 (未修改) 自从上次请求后，请求的网页未修改过。

4开头的表示请求可能出错，妨碍了服务器的处理

404服务器找不到请求的网页

5开头的表示服务器错误，服务器在处理请求时发生内部错误。

500服务器内部遇到错误，无法完成请求

####15、TCP/IP协议：

TCP/IP协议
链路层：对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据；

网络层：定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发；

传输层：定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序；

应用层：定义数据格式，并按照对应的格式解读数据。

通过http发起一个请求时，应用层、传输层、网络层和链路层的相关协议依次对该请求进行包装并携带对应的首部，最终在链路层生成以太网数据包，以太网数据包通过物理介质传输给对方主机，对方接收到数据包以后，然后再一层一层采用对应的协议进行拆包，最后把应用层数据交给应用程序处理。