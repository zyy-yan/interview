### 数据库面试问题：

####一、数据库范式：

范式是关系数据库理论的基础迷失在设计数据库结构过程种索要遵循的规则和指导方法。目前共有8种饭时，1NF，2NF，3NF，BCNF，4NF，5NF，6NF。通常所用到的都是前三个范式。

- **第一范式(1NF)  无重复的列**

强调的是列的原子性，即列不能够再分成其他几列。即数据表中的字段都是单一属性的，不可再分。简而言之，第一范式就是无重复的列。第一范式是对关系模式的基本要求，不满足第一范式的数据库就不是关系数据库。

- **第二范式(2NF) 属性完全依赖于主键【消除部分子函数依赖】**

第二范式是在第一范式的基础上建立起来的，满足第二范式必须先满足第一范式

第二范式要求数据库白哦中的每个实例或行必须可以被唯一的区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。这个唯一属性列被称为主关键字或主键，主码。

所有单关键字的数据库表都符合第二范式，因为不可能存在组合关键字。

- **第三范式(3NF)属性不依赖于其他非主属性【消除传递依赖】**

如果关系模式R是第二范式，且每个非主属性都不传递依赖于R的候选键，则称为第三范式模式。满足第三范式必须先满足第二范式。第三范式要求一个数据库表中不包含已在其它表中已包含的非主键关键信息。

在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。简言之，第三范式就是属性不依赖于其他非主属性。

####二、数据库事务：

事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。

事务的特征：

- 原子性：事务所包含的一系列数据库操作要么全部执行，要么全部回滚

- 一致性：事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态

- 隔离性：并发执行的事务之间不能相互影响

- 持久性：事务一旦提交，对数据库中数据的改变使永久性的

Mysql对事务的支持：mysql对事务的支持不是绑定在mysql服务器本身，而是与存储引擎有关

MyISAM：不支持事务，用于只读程序提高性能

InnoDB：支持ACID事务，行级锁、并发。

Berkeley DB：支持事务

####三、如何优化MySql：

mysql优化主要涉及SQL语句及索引的优化、数据表结构的优化、系统配置的优化和硬件的优化

####四、NOSQL数据库——Redis：

Redis是一款基于内存的且持久化、高性能的Key-value NoSQL数据库，其支持丰富数据类型（string,list,set,sorted set,hash）,常被用作缓存的解决方案。Redis具有以下显著特点：

- 速度快，因为数据在内存中，类似于HashMap,HashMap的优势就是查找和操作的时间复杂度都是O(1)

- 支持丰富数据类型，支持string，list，set,sorted set, hash

- 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行

- 丰富的特性：可用于缓存，消息，按Key设置过期时间，过期后将会自动删除

####五、数据库索引

- **概念**

**索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。**索引的实现通常使用B_tree及其变种。索引加速了数据访问，因为存储引擎不会再去扫描整张表得到需要的数据；相反它从根节点开始，根节点保存了子节点的指针，存储引擎会根据指针快速寻找数据。

**优势：**可以快速检索，减少I/O次数，加快检索速度；根据索引分组和排序，可以加快分组和排序；

**劣势：**索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍；索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表；

- **索引的分类：**

主键索引：即主索引，根据主键pk_clolum（length）建立索引，**不允许重复，不允许空值**；

唯一索引：用来建立索引的列的值必须是**唯一的，允许空值**。**主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。**

普通索引：用表中的普通列构建的索引，没有任何限制(非主键索引)

全文索引：用大文本对象的列构建的索引

组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值

- **索引类型**

MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如**BTree索引，B+Tree索引，哈希索引，全文索引**

**哈希索引**：只有内存存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执呆滞所在行数据的物理位置，因为使用散列算法，**因此访问速度特别快，但是一个之只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。**

 **全文索引：**FULLTEXT(全文)索引，仅适用MyISAM和InnoDB，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的char类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可以的，但是想要匹配文本中间的几个单词，那么就要使用like%word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可以使用FULLTEXT索引了，在生成全文索引时，会为文本生成一份单词的清单，在索引时根据这个单词的清单来索引。

**BTree索引：**BTree是平衡搜索多叉树，设树的度为2d（d>1），高度为h，那么BTree要满足以一下条件：

1.每个叶子结点的高度一样，等于h；

2.每个非叶子结点由**n-1个key**和**n个指针point**组成，其中d<=n<=2d,key和point相互间隔，结点两端一定是key；

3.叶子结点指针都为null；

4.非叶子结点的key都是[key,data]二元组，其中key表示作为索引的键，data为键值所在行的数据；

在BTree的机构下，就可以使用二分查找的查找方式，查找复杂度为h*log(n)，一般来说树的高度是很小的，一般为3左右，因此BTree是一个非常高效的查找结构。

**B+Tree索引：**B+Tree是BTree的一个变种，设d为树的度数，h为树的高度，B+Tree和BTree的不同主要在于：

1.B+Tree中的非叶子结点不存储数据，只存储键值；

2.B+Tree的叶子结点没有指针，所有键值都会出现在叶子结点上，且key存储的键值对应data数据的物理地址；

3.B+Tree的每个非叶子节点由**n个键值key**和**n个指针point**组成；

- **B+Tree对比BTree的优点：**

1.一般来说B+Tree比BTree更适合实现外存的索引结构，因为存储引擎的设计专家巧妙的利用了外存（磁盘）的存储结构。那么**提升查找速度的关键就在于尽可能少的磁盘I/O，那么可以知道，每个节点中的key个数越多，那么树的高度越小，需要I/O的次数越少，因此一般来说B+Tree比BTree更快，因为B+Tree的非叶节点中不存储data，就可以存储更多的key**。

2.查询速度更稳定

由于B+Tree非叶子节点不存储数据（data），因此所有的数据都要查询至叶子节点，而叶子节点的高度都是相同的，因此所有数据的查询速度都是一样的。

- **主键就是聚集索引吗？主键和索引有什么区别？**

**主键是一种特殊的唯一性索引，其可以是聚集索引，也可以是非聚集索引。**在SQLServer中，主键的创建必须依赖于索引，默认创建的是聚集索引，但也可以显式指定为非聚集索引。**InnoDB作为MySQL存储引擎时，默认按照主键进行聚集，**如果没有定义主键，InnoDB会试着使用唯一的非空索引来代替。如果没有这种索引，InnoDB就会定义隐藏的主键然后在上面进行聚集。所以，**对于聚集索引来说，你创建主键的时候，自动就创建了主键的聚集索引。**

- **聚集索引和非聚集索引的区别：**

1、聚集索引表示表中存储的数据按照索引的顺序存储，检索效率比非聚集索引高，但对数据更新影响较大。（比如主键索引）

2、非聚集索引表示数据存储在另一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。非聚集索引检索效率比聚集索引低，但对数据更新影响较小。

#### 六、什么是存储过程？有哪些有点？

存储过程事先现经过编译并存储在数据库中的一段SQL语句的集合。进一步地说，存储过程是由一些T-SQL语句组成地代码块，这些T-SQL语句代码像一个方法一样实现一些功能，然后再给这个代码块取一个名字，在用到这个功能的时候直接调用就行。存储过程具有以下特点：

- 存储过程只在创建时进行编译，以后每次执行存储过程都不需要再进行重新编译，而一般SQL语句每执行一次就编译一次，所以存储过程可以提高数据库执行效率
- 当SQL语句有变动时，可以只修改数据库中的存储过程而不必修改代码
- 减少网络传输，在客户端调用一个存储过程当然比执行一串SQL传输的数据量要小
- 通过存储过程能够使没有权限的用具在控制之下间接的存取数据库，从而确保数据的安全

#### 七，简单说说drop、delete与truncate的区别

SQL中的drop、delete、truncate都表示删除，但是三者有一些区别：

- delete用来删除表中的全部数据或者部分数据行，执行delete之后，用户需要提交或者回滚来执行删除或者撤销删除，delete命令会触发这个表上所有的delete触发器
- turncate删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器，turncate比delete更快，占用的空间更小
- drop命令从数据库中删除表，所有的数据行，索引和权限也会被删除，所有的DML触发器也不会被触发，这个命令也不能回滚。

#### 八、视图

视图是一种虚拟的表，通常是有一个表或者多个表的行或列的子集，具有和物理表相同的功能，可以对视图进行增、删、改、查等操作。特别地，对视图的修改不影响基本表。相比多表查询，它使得我们获取数据更容易。

#### 九、触发器

触发器是与表相关的数据库对象，在满足定义条件时出发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用再数据库端确保数据库的完整性

#### 十、Mysql中的悲观锁和乐观锁的实现

悲观锁与乐观锁是两种常见的资源并并发锁设计思路，也是并发编程中一个非常基础的概念

- 悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁(共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程)。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。通常来讲，在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。

- 乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。乐观锁的特点先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过，若未被更新过，则更新成功；否则，失败重试。乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。

- 乐观锁与悲观锁的应用场景

一般情况下，读多写少更适合用乐观锁，读少写多更适合用悲观锁。乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能。

#### 十一、MySQL存储引擎的MyISAM和InnoDB详解区别

MyISAM是mysql的默认存储引擎，虽然MyISAM性能极佳，但是有一个明确的缺点：不支持事务处理。mySQL也导入了另一种数据库引擎InnoDB，以强化参考完整性与并发违规处理机制，**InnoDB的最大特色就是支持ACID兼容的事务功能**。

- **存储结构不同：**每个MyISAM在磁盘上存储成三个文件：.frm文件存储表定义，数据文件的扩展名为。MYD，索引文件的扩展名.MYI。InnoDB所有的表都保存在同一个数据文件中，InnoDB的表只受限于操作系统文件的大小
- **存储空间：**MyISAM可被压缩，占据的存储空间小，支持静态表、动态表、压缩表三种不同的存储格式。InnoDB需要更多的内存和存储，它会在内存中建立其专用的缓冲池用于告诉缓冲数据和索引
- **可移植性、备份及恢复：**MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便，同时在备份和回复时也可单独针对某个表进行操作。InnoDB免费的方案可以是拷贝数据文件、备份binlog，或者用mysqldump，数据量达到几十G就很痛苦了
- **事务支持：**MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB类型更快，但是不提供事务支持。InnoDB提供事务，外键等高级数据库功能，具有事务提交、回滚和崩溃修复能力。
- **表锁差异：**MyISAM只支持表级锁，用户在操作MyISAM表时，select、update、delete和insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。InnoDB支持事务和行级锁。行锁大幅度提高了多用户并发操作的新能，但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。
- **全文索引：**MyISAM支持 FULLTEXT类型的全文索引；InnoDB不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。
- **表主键：**MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址。对于InnoDB，如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。
- **外键：**MyISAM不支持外键，而InnoDB支持外键。

#### 十二、数据库连接池

对于一个简单的数据库应用，由于对于数据库的访问不是很频繁。这时可以简单地在需要访问数据库时，就新创建一个连接，用完后就关闭它，这样做也不会带来什么明显的性能上的开销。但是对于一个复杂的数据库应用，情况就完全不同了。频繁的建立、关闭连接，会极大的减低系统的性能，因为对于连接的使用成了系统性能的瓶颈。

连接复用。通过建立一个数据库连接池以及一套连接使用管理策略，使得一个数据库连接可以得到高效、安全的复用，避免了数据库连接频繁建立、关闭的开销。数据库连接池的基本原理是在内部对象池中维护一定数量的数据库连接，并对外暴露数据库连接获取和返回方法。

**数据库连接池技术带来的优势**：

1． 资源重用

由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增进了系统运行环境的平稳性（减少内存碎片以及数据库临时进程/线程的数量）。

2． 更快的系统响应速度

数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间。

3． 新的资源分配手段

对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接的配置，实现数据库连接池技术，几年钱也许还是个新鲜话题，对于目前的业务系统而言，如果设计中还没有考虑到连接池的应用，那么…….快在设计文档中加上这部分的内容吧。某一应用最大可用数据库连接数的限制，避免某一应用独占所有数据库资源。

4． 统一的连接管理，避免数据库连接泄漏

在较为完备的数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用连接。从而避免了常规数据库连接操作中可能出现的资源泄漏。

#### 十三、事务的隔离级别

#####事务的并发问题：

1、**脏读：**脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。（事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据）

2、**不可重复读：**是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。）

3、**幻读：**第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。（系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。）

**小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表**

#####**隔离级别（InnoDB默认是可重复读）**：

| 隔离级别 |  脏读  | 不可重复读 |  幻读  |
| :------: | :----: | :--------: | :----: |
| 未提交读 |  可能  |    可能    |  可能  |
| 已提交读 | 不可能 |    可能    |  可能  |
| 可重复读 | 不可能 |   不可能   |  可能  |
| 可串行化 | 不可能 |   不可能   | 不可能 |

- 未提交读(Read Uncommitted)：一个事务在执行过程中可以看到其他事务没有提交的新插入的记录，而且还能看到其他事务没有提交的对已有记录的更新。允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。
- 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)
- 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读
- 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

**1、事务隔离级别为读提交时，写数据只会锁住相应的行**

**2、事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key 锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。**

**3、事务隔离级别为串行化时，读写数据都会锁住整张表**

**4、隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。**

####十四、数据库主从同步



#### 数据库索引

我先说下什么是索引，索引是对数据库表中一个或多个列的值进行排序的数据结构，协助快速查询、更新数据库表中数据。主要目的就是加快检索表中数据，能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。

索引的优点是：通过建立索引可以极大地提高在数据库中获取所需信息的速度，同时还能提高服务器处理相关搜索请求的效率。

但是索引也有缺点，它的缺点是：在数据库中创建索引，需要占用一定的物理存储空间；索引表的维护和创建需要时间成本，这个成本随着数据量增大越来越大；对表中的数据进行修改时，还需要修改索引表，这给数据库的维护带来了一定的麻烦。

索引的底层实现是B+树，B+树比B树更适合数据库索引。

**B+树的磁盘读写代价更低：**B+树的中间节点不保存数据，能容纳更多节点元素，如果把同一内部节点的关键字存放在同一盘块中，那么能容纳的关键字数量就越多，一次性读入内存需要查找的关键字就越多，相对IO读写次数就降低了。
**B+树的查询效率更加稳定：**任何关键字的查找必须走一条从根节点到叶子节点的路，所有关键字查找的路径长度相同，导致每一个数据的查询效率更加稳定。
**B+树的区间查找遍历更高效：**由于B+树的数据都存储在叶子节点中，叶子节点用链表连接，区间查找和遍历只需要扫一遍叶子节点即可，B树因为其分支节点同样存储数据，要找到具体的数据，需要进行每一层的递归和遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好，通常用B+树作数据库索引。

**聚集索引（聚簇索引）**。表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。 在一张表上最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种。(B+树)如果不创建索引，系统会自动创建一个隐含列表作为聚集索引。

**非聚集索引（非聚簇索引）。**该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致。

MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。

InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。InnoDB的数据文件本身就是索引文件，数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。InnoDB的辅助索引data域存储相应记录主键的值而不是地址。

MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。



唯一索引：用来建立索引的列的值必须是**唯一的，允许空值**。**主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。**

普通索引：用表中的普通列构建的索引，没有任何限制(非主键索引)

全文索引：用大文本对象的列构建的索引





