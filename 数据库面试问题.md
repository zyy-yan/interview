### 数据库面试问题：

####一、数据库范式：

范式是关系数据库理论的基础迷失在设计数据库结构过程种索要遵循的规则和指导方法。目前共有8种饭时，1NF，2NF，3NF，BCNF，4NF，5NF，6NF。通常所用到的都是前三个范式。

- **第一范式(1NF)  无重复的列**

强调的是列的原子性，即列不能够再分成其他几列。即数据表中的字段都是单一属性的，不可再分。简而言之，第一范式就是无重复的列。第一范式是对关系模式的基本要求，不满足第一范式的数据库就不是关系数据库。

- **第二范式(2NF) 属性完全依赖于主键【消除部分子函数依赖】**

第二范式是在第一范式的基础上建立起来的，满足第二范式必须先满足第一范式

第二范式要求数据库白哦中的每个实例或行必须可以被唯一的区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。这个唯一属性列被称为主关键字或主键，主码。

所有单关键字的数据库表都符合第二范式，因为不可能存在组合关键字。

- **第三范式(3NF)属性不依赖于其他非主属性【消除传递依赖】**

如果关系模式R是第二范式，且每个非主属性都不传递依赖于R的候选键，则称为第三范式模式。满足第三范式必须先满足第二范式。第三范式要求一个数据库表中不包含已在其它表中已包含的非主键关键信息。

在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。简言之，第三范式就是属性不依赖于其他非主属性。

####二、数据库事务：

事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。

事务的特征：

- 原子性：事务所包含的一系列数据库操作要么全部执行，要么全部回滚

- 一致性：事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态

- 隔离性：并发执行的事务之间不能相互影响

- 持久性：事务一旦提交，对数据库中数据的改变使永久性的

Mysql对事务的支持：mysql对事务的支持不是绑定在mysql服务器本身，而是与存储引擎有关

MyISAM：不支持事务，用于只读程序提高性能

InnoDB：支持ACID事务，行级锁、并发。

Berkeley DB：支持事务

####三、如何优化MySql：

mysql优化主要涉及SQL语句及索引的优化、数据表结构的优化、系统配置的优化和硬件的优化

####四、NOSQL数据库——Redis：

Redis是一款基于内存的且持久化、高性能的Key-value NoSQL数据库，其支持丰富数据类型（string,list,set,sorted set,hash）,常被用作缓存的解决方案。Redis具有以下显著特点：

- 速度快，因为数据在内存中，类似于HashMap,HashMap的优势就是查找和操作的时间复杂度都是O(1)

- 支持丰富数据类型，支持string，list，set,sorted set, hash

- 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行

- 丰富的特性：可用于缓存，消息，按Key设置过期时间，过期后将会自动删除

####五、数据库索引

- **概念**

**索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。**索引的实现通常使用B_tree及其变种。索引加速了数据访问，因为存储引擎不会再去扫描整张表得到需要的数据；相反它从根节点开始，根节点保存了子节点的指针，存储引擎会根据指针快速寻找数据。

**优势：**可以快速检索，减少I/O次数，加快检索速度；根据索引分组和排序，可以加快分组和排序；

**劣势：**索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍；索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表；

- **索引的分类：**

主键索引：即主索引，根据主键pk_clolum（length）建立索引，**不允许重复，不允许空值**；

唯一索引：用来建立索引的列的值必须是**唯一的，允许空值**。**主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。**

普通索引：用表中的普通列构建的索引，没有任何限制(非主键索引)

全文索引：用大文本对象的列构建的索引

组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值

- **索引类型**

MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如**BTree索引，B+Tree索引，哈希索引，全文索引**

**哈希索引**：只有内存存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执呆滞所在行数据的物理位置，因为使用散列算法，**因此访问速度特别快，但是一个之只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。**

 **全文索引：**FULLTEXT(全文)索引，仅适用MyISAM和InnoDB，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的char类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可以的，但是想要匹配文本中间的几个单词，那么就要使用like%word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可以使用FULLTEXT索引了，在生成全文索引时，会为文本生成一份单词的清单，在索引时根据这个单词的清单来索引。

**BTree索引：**BTree是平衡搜索多叉树，设树的度为2d（d>1），高度为h，那么BTree要满足以一下条件：

1.每个叶子结点的高度一样，等于h；

2.每个非叶子结点由**n-1个key**和**n个指针point**组成，其中d<=n<=2d,key和point相互间隔，结点两端一定是key；

3.叶子结点指针都为null；

4.非叶子结点的key都是[key,data]二元组，其中key表示作为索引的键，data为键值所在行的数据；

在BTree的机构下，就可以使用二分查找的查找方式，查找复杂度为h*log(n)，一般来说树的高度是很小的，一般为3左右，因此BTree是一个非常高效的查找结构。

**B+Tree索引：**B+Tree是BTree的一个变种，设d为树的度数，h为树的高度，B+Tree和BTree的不同主要在于：

1.B+Tree中的非叶子结点不存储数据，只存储键值；

2.B+Tree的叶子结点没有指针，所有键值都会出现在叶子结点上，且key存储的键值对应data数据的物理地址；

3.B+Tree的每个非叶子节点由**n个键值key**和**n个指针point**组成；

- **B+Tree对比BTree的优点：**

1.一般来说B+Tree比BTree更适合实现外存的索引结构，因为存储引擎的设计专家巧妙的利用了外存（磁盘）的存储结构。那么**提升查找速度的关键就在于尽可能少的磁盘I/O，那么可以知道，每个节点中的key个数越多，那么树的高度越小，需要I/O的次数越少，因此一般来说B+Tree比BTree更快，因为B+Tree的非叶节点中不存储data，就可以存储更多的key**。

2.查询速度更稳定

由于B+Tree非叶子节点不存储数据（data），因此所有的数据都要查询至叶子节点，而叶子节点的高度都是相同的，因此所有数据的查询速度都是一样的。

- **主键就是聚集索引吗？主键和索引有什么区别？**

**主键是一种特殊的唯一性索引，其可以是聚集索引，也可以是非聚集索引。**在SQLServer中，主键的创建必须依赖于索引，默认创建的是聚集索引，但也可以显式指定为非聚集索引。**InnoDB作为MySQL存储引擎时，默认按照主键进行聚集，**如果没有定义主键，InnoDB会试着使用唯一的非空索引来代替。如果没有这种索引，InnoDB就会定义隐藏的主键然后在上面进行聚集。所以，**对于聚集索引来说，你创建主键的时候，自动就创建了主键的聚集索引。**

- **聚集索引和非聚集索引的区别：**

1、聚集索引表示表中存储的数据按照索引的顺序存储，检索效率比非聚集索引高，但对数据更新影响较大。（比如主键索引）

2、非聚集索引表示数据存储在另一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。非聚集索引检索效率比聚集索引低，但对数据更新影响较小。

#### 六、什么是存储过程？有哪些有点？

存储过程事先现经过编译并存储在数据库中的一段SQL语句的集合。进一步地说，存储过程是由一些T-SQL语句组成地代码块，这些T-SQL语句代码像一个方法一样实现一些功能，然后再给这个代码块取一个名字，在用到这个功能的时候直接调用就行。存储过程具有以下特点：

- 存储过程只在创建时进行编译，以后每次执行存储过程都不需要再进行重新编译，而一般SQL语句每执行一次就编译一次，所以存储过程可以提高数据库执行效率
- 当SQL语句有变动时，可以只修改数据库中的存储过程而不必修改代码
- 减少网络传输，在客户端调用一个存储过程当然比执行一串SQL传输的数据量要小
- 通过存储过程能够使没有权限的用具在控制之下间接的存取数据库，从而确保数据的安全

#### 七，简单说说drop、delete与truncate的区别

SQL中的drop、delete、truncate都表示删除，但是三者有一些区别：

- delete用来删除表中的全部数据或者部分数据行，执行delete之后，用户需要提交或者回滚来执行删除或者撤销删除，delete命令会触发这个表上所有的delete触发器
- turncate删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器，turncate比delete更快，占用的空间更小
- drop命令从数据库中删除表，所有的数据行，索引和权限也会被删除，所有的DML触发器也不会被触发，这个命令也不能回滚。

#### 八、视图

视图是一种虚拟的表，通常是有一个表或者多个表的行或列的子集，具有和物理表相同的功能，可以对视图进行增、删、改、查等操作。特别地，对视图的修改不影响基本表。相比多表查询，它使得我们获取数据更容易。

#### 九、触发器

触发器是与表相关的数据库对象，在满足定义条件时出发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用再数据库端确保数据库的完整性

#### 十、Mysql中的悲观锁和乐观锁的实现

悲观锁与乐观锁是两种常见的资源并并发锁设计思路，也是并发编程中一个非常基础的概念

- 悲观锁

总是假设最坏的情况，每次去拿数据的嘶吼都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁(共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程)。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。通常来讲，在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。

- 乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。乐观锁的特点先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过，若未被更新过，则更新成功；否则，失败重试。乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。

- 乐观锁与悲观锁的应用场景

一般情况下，读多写少更适合用乐观锁，读少写多更适合用悲观锁。乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能。

#### 十一、MySQL存储引擎的MyISAM和InnoDB详解区别

MyISAM是mysql的默认存储引擎，虽然MyISAM性能极佳，但是有一个明确的缺点：不支持事务处理。mySQL也导入了另一种数据库引擎InnoDB，以强化参考完整性与并发违规处理机制，**InnoDB的最大特色就是支持ACID兼容的事务功能**。

- **存储结构不同：**每个MyISAM在磁盘上存储成三个文件：.frm文件存储表定义，数据文件的扩展名为。MYD，索引文件的扩展名.MYI。InnoDB所有的表都保存在同一个数据文件中，InnoDB的表只受限于操作系统文件的大小
- **存储空间：**MyISAM可被压缩，占据的存储空间小，支持静态表、动态表、压缩表三种不同的存储格式。InnoDB需要更多的内存和存储，它会在内存中建立其专用的缓冲池用于告诉缓冲数据和索引
- **可移植性、备份及恢复：**MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便，同时在备份和回复时也可单独针对某个表进行操作。InnoDB免费的方案可以是拷贝数据文件、备份binlog，或者用mysqldump，数据量达到几十G就很痛苦了
- **事务支持：**MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB类型更快，但是不提供事务支持。InnoDB提供事务，外键等高级数据库功能，具有事务提交、回滚和崩溃修复能力。
- **表锁差异：**MyISAM只支持表级锁，用户在操作MyISAM表时，select、update、delete和insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。InnoDB支持事务和行级锁。行锁大幅度提高了多用户并发操作的新能，但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。
- **全文索引：**MyISAM支持 FULLTEXT类型的全文索引；InnoDB不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。
- **表主键：**MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址。对于InnoDB，如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。
- **外键：**MyISAM不支持外键，而InnoDB支持外键。





