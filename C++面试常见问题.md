###C++面试常见问题

####一、C/C++中static关键字的作用

- **C面向过程的static关键字：**

**1、静态全局变量：**在全局变量前加上关键字static，该变量就被定义成为一个静态全局变量。

静态全局变量有以下特点：
• 该变量在全局数据区分配内存；
• 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；
• 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；　

**代码区**
**全局数据区**
**堆区**
**栈区**

一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。

**2、静态局部变量：**在局部变量前加上关键字static，该变量就被定义成为一个静态局部变量。

静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。

静态局部变量有以下特点：
• 该变量在全局数据区分配内存；
• 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
• 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；
• 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；

**3、静态函数：**在函数的返回类型前加上static关键字，函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。

定义静态函数的好处：
• 静态函数不能被其它文件所用；
• 其它文件中可以定义相同名字的函数，不会发生冲突；

- **C++面向对象的static关键字：**

**1、类静态数据成员：**在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。

• 对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；
• 静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。
• 静态数据成员和普通数据成员一样遵从public,protected,private访问规则；
• 因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；
• 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：
＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞
• 类的静态数据成员有两种访问形式：
＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞
如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ；
• 静态数据成员主要用在各个对象都有相同的某项属性的时候。
• 同全局变量相比，使用静态数据成员有两个优势：

1. 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；
2. 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；

**2、类静态成员函数：**与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。

关于静态成员函数，可以总结为以下几点：
• 出现在类体外的函数定义不能指定关键字static；
• 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；
• 非静态成员函数可以任意地访问静态成员函数和静态数据成员；
• 静态成员函数不能访问非静态成员函数和非静态数据成员；
• 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；
• 调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：＜类名＞::＜静态成员函数名＞（＜参数表＞）调用类的静态成员函数。

------

####二、C和C++的区别：

**1、语言**

- C语言是面向过程的语言，是具体化，流程化的，解决一个问题，需要一步一步的分析，一步一步的实现；

- C++是模型化的，你只要抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以，不必一步一步去实现；

**2、宏与模板**

C++ 的模板在设计之初的一个用途就是用来替换宏定义。模板不同于宏的文字替换，在编译时会得到更全面的编译器检查，便于编写更健全的代码，利用 inline 关键字还能获得编译器充分的优化。

**3、struct和class**

C 中的 struct 用来描述一种固定的内存组织结构，而 C++ 中的 struct 就是一种类， **它与类唯一的区别就是它的成员和继承行为默认是 public 的** ，而一般类的默认成员是 private 的。

4、C++ 对 C 的增强，表现在六个方面：

- 增强了类型检查机制
- 增加了面向对象的机制
- 增加了泛型编程的机制（template）
- 增加了异常处理
- 增加了重载的机制
- 增加了标准模板库（STL）

------

####三、C++中的类型转化：

**C++类型转换大体上包括隐式类型转换和显式类型转换。**

**1、隐式类型转化**

隐式类型转换是自动执行的，无需显式的操作符。 隐式类型转换发生在很多地方，比如函数实参到形参的类型转换、函数返回值类型的自动转换等等。

**1.1、数值类型转化：**从小整数类型(char、short)转换到int，或者从float转换到double，这种“提升型”的转换通常不会造成数值差异。

**1.2、指针类型转化：**指针通常存在以下转换：

- 空指针可以转换到任意指针类型；
- 任意指针类型都可以转换到void* 指针；
- 继承类指针可以转换到可访问的明确的基类指针， 同时不改变const或者volatile属性;
- 一个C风格的数组隐式把数组的第一个元素转换为一个指针。

**2、显示类型转化**

**2.1、explicit关键字：**C++提供了关键字explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生。即声明为explicit的构造函数不能在隐式转换中使用。	

**2.2、强制类型转化：**

**reinterpret_cast：**可以用于任意类型的指针之间的转换，对转换的结果不做任何保证
**dynamic_cast：**这种其实也是不被推荐使用的，更多使用static_cast，dynamic本身只能用于存在虚函数的父子关系的强制类型转换，对于指针，转换失败则返回nullptr，对于引用，转换失败会抛出异常
**const_cast：**对于未定义const版本的成员函数，我们通常需要使用const_cast来去除const引用对象的const，完成函数调用。另外一种使用方式，结合static_cast，可以在非const版本的成员函数内添加const，调用完const版本的成员函数后，再使用const_cast去除const限定。
**static_cast：**完成基础数据类型转化；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换。

**2.2.1、static_cast**：

```
static_cast <new_type> (expression)
```

**static_cast强制转换只会在编译时检查，但没有运行时类型检查来保证转换的安全性。所以这类型的强制转换和C语言风格的强制转换都有安全隐患。**主要应用场景：

- 用于类层次结构中基类和子类之间指针或引用的转换。进行上行转换（把子类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成子类指针或引用）时，由于没有动态类型检查，所以是不安全的。
- 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
- 把void指针转换成目标类型的指针(不安全!!)
- 把任何类型的表达式转换成void类型
- 将enum class值转化为整数或者浮点数
- 转换为右值引用

**2.2.2、const_cast:**

```
const_cast <new_type> (expression)
```

new_type 必须是一个指针、引用或者指向对象类型成员的指针。**const_cast用于去除除对象的const或者volatile属性。**

- 常量指针被转化成非常量的指针，并且仍然指向原来的对象；
- 常量引用被转换成非常量的引用，并且仍然指向原来的对象；
- const_cast一般用于修改指针。如const char *p形式。

**2.2.3、dynamic_cast:**

```
dynamic_cast <new_type> (expression)
```

**dynamic_cast 在运行时执行转换，验证转换的有效性。**new_type 必须是一个指针或引用或“指向 void 的指针”。 如果 new_type 是指针，则expression 的类型必须是指针，如果 type-id 是引用，则expression为左值。 如果转型失败会返回null（转型对象为指针时）或抛出异常（转型对象为引用时)。dynamic_cast 会动用运行时信息（RTTI）来进行类型安全检查，因此dynamic_cast 存在一定的效率损失。

dynamic_cast 的一个重要作用就是要确保转换结果应该指向一个完整的目标类型。此外，dynamic_cast只有在基类存在虚函数(虚函数表)的情况下才有可能将基类指针转化为子类。

**2.2.4、reinterpret_cast：**

```
reinterpret_cast <new_type> (expression)
```

**reinterpret_cast 运算符把某种指针改为其他类型的指针。它可以把一个指针转换为一个整数，也可以把一个整数转换为一个指针。**new_type必须是一个指针、引用、算术类型、函数指针或者成员指针。其转换结果与编译平台息息相关，不具有可移植性，因此在一般的代码中不常见到它。**reinterpret_cast 常用的一个用途是转换函数指针类型，即可以将一种类型的函数指针转换为另一种类型的函数指针，但这种转换可能会导致不正确的结果。**

------

#### 四、C++中的四个智能指针

**1、为什么要使用智能指针？**

如果一块内存被多个指针引用，但其中的一个指针释放且其余的指针并不知道，这样的情况下，就发生了挂起引用。而内存泄露，就如你知道的一样，当从堆中申请了内存后不释放回去，这时就会发生内存泄露。使用智能指针可以很大程度上避免这个问题，智能指针是一个`RAII`（`Resource Acquisition is initialization`）类模型，用来动态的分配内存。它提供所有普通指针提供的接口，却很少发生异常。在构造中，它分配内存，当离开作用域时，它会自动释放已分配的内存。

**2、四个智能指针：**

- **auto_ptr**:**auto_ptr这个智能指针在新的C++11标准中已经不太常用**，它有以下几个问题：

  1、**当把一个auto_ptr赋给另外一个auto_ptr时，它的所有权(ownship)也转移了。**当我在函数间传递`auto_ptr`时，这就是一个问题。例如，我在`Foo()`中有一个`auto_ptr`，然后在`Foo()`中我把指针传递给了`Fun()`函数，当`Fun()`函数执行完毕时，指针的所有权不会再返还给`Foo`。

  2、**auto_ptr不能指向一组对象，就是说他不能和操作符new[]一起使用。**因为当`auto_ptr`离开作用域时，`delete`被默认用来释放关联的内存空间。

  3、**auto_ptr不能和标准容器（vector,list,map……）一起使用**

- **shared_ptr：shared_ptr共享所有权。可以被多个指针共享，多个指针可以同时指向一个对象，当最后一个shared_ptr离开作用域时，内存才会自动释放。**

  **创建：**尽量使用make_shared宏来加速创建的过程。make_shared以一种更有效率的方法来实现创建工作。可以通过调用use_count()得到资源的引用计数，找到shared_ptr的数量。

  **析构**：shared_ptr默认调用delete释放关联的资源。如果用户采用一个不一样的析构策略时，他可以自由指定构造这个shared_ptr的策略。比如：shared_ptr指向一组对象，但是当离开作用域时，默认的析构函数调用delete释放资源。实际上，我们应该调用delete[]来销毁这个数组。用户可以通过调用一个函数，例如一个lamda表达式，来指定一个通用的释放步骤。

  ```
  shared_ptr<Test> sptr1( new Test[5], [ ](Test* p) { delete[ ] p; } );
  ```

  **接口：**就像一个普通指针一样，shared_ptr也提供解引用操作符*,->。除此之外，它还提供了一些更重要的接口：

  -  `get()`: 获取`shared_ptr`绑定的资源.
  -  `reset()`: 释放关联内存块的所有权，如果是最后一个指向该资源的`shared_ptr`,就释放这块内存。
  -  `unique`: 判断是否是唯一指向当前内存的`shared_ptr`.
  -  `operator bool` : 判断当前的`shared_ptr`是否指向一个内存块，可以用if 表达式判断。
  - release():当前指针会释放资源所有权，计数减一。

  **存在的问题：**

  - 如果几个`shared_ptrs`指向的内存块属于不同组，将产生错误。

  - 如果从一个普通指针创建一个`shared_ptr`还会引发另外一个问题。

  - 循环引用：如果共享智能指针卷入了循环引用，资源都不会正常释放

- **weak_ptr:**weak_ptr用来解决shared_ptr循环引用的的问题。`weak_ptr` 拥有共享语义和不包含语义。这意味着，`weak_ptr`可以共享`shared_ptr`持有的资源。所以可以从一个包含资源的`shared_ptr`创建`weak_ptr`。

  **创建**:可以以`shared_ptr`作为参数构造`weak_ptr`.从`shared_ptr`创建一个`weak_ptr`增加了共享指针的弱引用计数，意味着`shared_ptr`与其它的指针共享着它所拥有的资源。但是当`shared_ptr`离开作用域时，这个计数不作为是否释放资源的依据。换句话说，就是除非强引用计数变为`0`，才会释放掉指针指向的资源，

  如何判断`weak_ptr`是否指向有效资源，有两种方法：

  1. 调用`use-count()`去获取引用计数，该方法只返回强引用计数，并不返回弱引用计数。
  2. 调用`expired()`方法。比调用`use_count()`方法速度更快。

  从`weak_ptr`调用`lock()`可以得到`shared_ptr`或者直接将`weak_ptr`转型为`shared_ptr`

- **unique_ptr:**`unique_ptr`也是对`auto_ptr`的替换。`unique_ptr`遵循着独占语义。在任何时间点，资源只能唯一地被一个`unique_ptr`占有。当`unique_ptr`离开作用域，所包含的资源被释放。如果资源被其它资源重写了，之前拥有的资源将被释放。所以它保证了他所关联的资源总是能被释放。

  **创建：**unique_ptr的创建方法和shared_ptr一样，但是unique_ptr提供了创建数组对象的特殊方法，当指针离开作用域时，调用delete[]代替delete。当创建unique_ptr时，这一组对象被视作模板参数的部分。

  当把`unique_ptr`赋给另外一个对象时，资源的所有权就会被转移。

  `unique_ptr`不提供复制语义（拷贝赋值和拷贝构造都不可以），只支持移动语义(`move semantics`).

------

#### 四、野指针和悬空指针

野指针：野指针指，访问一个已删除或访问受限的内存区域的指针，野指针不能判断是否为NULL来避免。
产生的原因1、指针变量未初始化化。指针变量默认的值不是NULL，而是随机指。
悬空指针：一个指针的指向对象已被删除，那么就成了悬空指针。野指针是那些未初始化的指针。

####五、C++编译流程

- 预处理：处理所有的条件编译指令，比如#if，#include，预编译指令、删除所有的注释、添加行号和文件名标识等。

- 编译：编译会将源代码由文本形式转换成机器语言，编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析以及优化后生成相应的汇编代码文件。
  - 静态编译：编译器在编译可执行文件时，把需要用到的对应动态链接库(.so或.ilb)中的部分提取出来，链接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库.
  - 动态编译: 动态编译的可执行文件需要附带一个的动态链接库，在执行时，需要调用其对应动态链接库中的命令。

- 汇编：汇编过程调用汇编器AS来完成，是用于将汇编代码转换成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。（非底层的程序员不需要考虑）汇编后的.o文件是纯二进制文件。

- 链接：链接是将所有的.o文件和库（动态库、静态库）链接在一起，得到可以运行的可执行文件（Windows的.exe文件或Linux的.out文件）等。它的工作就是把一些指令对其他符号地址的引用加以修正。链接过程主要包括了地址和空间分配、符号决议和重定向。

------

####五、指针和引用的区别

**指针和引用主要有以下区别：**

- 引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。

- 引用初始化后不能被改变，指针可以改变所指的对象。

- 不存在指向空值的引用，但是存在指向空值的指针。

从概念上讲。指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。

而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。

- 指针是一个实体，而引用仅是个别名；
- 引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；
- **引用没有const，指针有const，const的指针不可变**；
- **引用不能为空，指针可以为空**；
- “**sizeof 引用**”得到的是所指向的变量(对象)的大小，而“**sizeof 指针**”得到的是指针本身的大小；
- 指针和引用的自增(++)运算意义不一样；
- 引用是类型安全的，而指针不是 (引用比指针多了类型检查）

------

#### 六、数组和链表的区别

数组是一种具有固定大小的数据结构，它将相同数据类型的元素在内存中连续存放，可通过下标快速访问数组中的任何元素。适合查询操作，插入和删除元素代价昂贵。

链表是一种采用链式结构的数据组织形式。它采用动态分配内存的形式实现，需要时可以用new分配内存空间，不需要时用delete释放已分配的空间，不会造成内存空间的浪费。适合插入和删除，查询操作开销较大。

数组元素存储在栈区，链表元素在堆区；

区别总结：

数组静态分配内存，链表动态分配内存；

数组元素在内存中连续存放，链表元素不连续；

（在程序执行过程中，申请的内存空间属于堆区，而栈区用于存放程序函数中的局部变量）

数组利用下标定位，查询操作的时间复杂度为O(1)，链表查询元素的时间复杂度为O(n)；

数据插入和删除元素的时间复杂度为O(n)，链表的时间复杂度为O(1)。



#### 六、封装、继承和多态

面向对象的三个基本特征是：封装、继承、多态。其中，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！

##### 1、封装

封装可以隐藏实现细节，使得代码模块化；封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。在面向对象编程上可理解为：**把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。**

##### 2、继承

继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。其继承的过程，就是从一般到特殊的过程。

通过继承创建的类称为子类或者派生类，被继承的类叫做父类或者基类。一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。

继承概念的实现方式有三类：实现继承、接口继承和可视继承。

- 实现继承是指使用基类的属性和方法而无需额外编码的能力；
- 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；
- 可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。

##### 3、多态

多态允许将子类类型的指针赋值给父类类型的指针，可以简单地概括为“一个接口，多种方法”，程序在运行时才决定要调用的函数。

多态有两种实现方式，覆盖和重载。

C++的多态性是通过虚函数来实现的，虚函数允许派生类重新定义成员函数，而派生类重新定义基类的做法称为覆盖，或者称为重写。（重写的话可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性）

而重载则是允许有多个同名的函数，而这些函数的参数列表不同，允许参数个数不同，参数类型不同，或者两者都不同。

------

#### 七、C++虚函数机制

**C++中虚函数表位于只读数据段(.rodata),也就是C++内存模型中的常量区；而虚函数则位于代码段(.text),也就是C++内存模型中的代码区**

C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数。虚函数的实现是通过虚函数表+虚表指针来实现的。编译器为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针(vptr)，这种数组成为虚函数表。即，每个类使用一个虚函数表，每个类对象使用一个虚表指针。

C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要再派生类中声明该方法为虚方法。

- 虚表指针vptr(只要基类有虚函数)，具体存在位置因编译器而定。

- 虚表指针指向虚表。虚表中动态绑定虚函数
- 类的非虚函数是静态的。地址不变，虚函数则是动态绑定。即如果子类重写了虚函数，就指向自己的虚函数地址。否则指向基类该函数的地址。

如果使用了**virtual**关键字，程序将根据**引用或指针**指向的 **对象类型** 来选择方法，否则使用**引用类型或指针类型**来选择方法。

虚函数的实现是通过虚函数表+虚表指针来实现的。编译器为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针(vptr)，这种数组成为虚函数表。即，每个类使用一个虚函数表，每个类对象使用一个虚表指针。

**基类对象包含一个虚表指针，指向基类中所有虚函数的地址表。派生类对象也将包含一个虚表指针，指向派生类虚函数表**。*看下面两种情况：*

- 如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址。
- 如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。



虚函数实现
虚函数表和虚标指针
现代的C++编译器对于每一个多态类型，其所有的虚函数的地址都以一个表V-Table的方式存放在一起，虚函数表的首地址储存在每一个对象之中，称为虚表指针vptr，这个虚指针一般位于对象的起始地址。通过虚指针和偏移量计算出虚函数的真实地址实现调用。
单继承模式
单继承就是派生类只有1个基类，派生类的虚函数表中包含了基类和派生类的全部虚函数，如果发生覆盖则以派生类为准。
多继承模式
当派生类有多个基类，在派生类中将出现多个虚表指针，指向各个基类的虚函数表，在派生类中会出现非覆盖和覆盖的情况
虚继承
虚继承是面向对象编程中的一种技术，是指一个指定的基类在继承体系结构中，将其成员数据实例共享给也从这个基类型直接或间接派生的其它类。


虚继承将共同基类设置为虚基类，从不同途径继承来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。从而解决了二义性问题、节省了内存，避免了数据不一致的问题。


为什么构造函数不能是虚函数

其他语言中可能会成立，但是在C++中存在问题，原因主要有：

构造对象时需要知道对象的实际类型，而虚函数行为是在运行期间才能确定实际类型的，由于对象还未构造成功，编译器无法知道对象的实际类型，俨然是个鸡和蛋的问题。

如果构造函数是虚函数，那么构造函数的执行将依赖虚函数表，而虚函数表又是在构造函数中初始化的，而在构造对象期间，虚函数表又还没有被初始化，又是个死循环问题。

总结：这块有点绕，从编译器的角度去看，构造函数就是为了在编译阶段确定对象类型、分配空间等工作，虚函数为了实现动态多态需要在运行期间才能确定具体的行为，显然构造函数不可能同时具备静态特性和动态特性。

虚函数的优缺点

虚函数的优点主要实现了C++的多态，提高代码的复用和接口的规范化，更加符合面向对象的设计理念，但是其缺点也比较明显，主要包括：

编译器借助于虚表指针和虚表实现时，导致类对象占用的内存空间更大，这种情况在子类无覆盖基类的多继承场景下更加明显。

虚函数表可能破坏类的安全性，可以根据地址偏移来访问Private成员

执行效率有损耗，因为涉及通过虚函数表寻址真正执行函数

------

#### 八、虚函数和纯虚函数的区别

纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”         virtual void funtion1()=0

**引入原因：**1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。

将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。
声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。
**纯虚函数最显著的特征是：**它们必须在继承类中重新声明函数，而且它们在抽象类中往往没有定义。
定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。

------

#### 九、C++中那些函数不能是虚函数

不能声明为虚函数的有：非成员函数、静态成员函数、内联成员函数、构造函数和友元函数

- **非成员函数不为虚函数：**普通函数（非成员函数）只能被overload，不能被override，因为编译器会在编译时邦定函数。
- **构造函数不为虚函数：**1、构造函数主要是为了明确初始化对象产生的，而虚函数主要是为了在信息不全的情况下，使得覆盖的函数得到对应的调用。如果构造函数是虚函数，找不到对应的调用。2、存储空间：虚函数对应一个指向虚函数表的指针，而指向虚函数表的指针存储在对象的内存空间。如果构造函数是虚的，那么就需要通过虚函数表来调用，而此时对象还没有初始化，内存空间还没有虚函数表。
- **内联函数不为虚函数：**内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，没法统一。内联函数在编译时被展开，虚函数在运行时才能动态的邦定函数
- **静态成员函数不为虚函数：**静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他不归某个具体对象所有。
- **友元函数不为虚函数：**因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。

#### 十、如果一个类A定义了虚函数，另一个类B定义了虚函数，一个派生类多重继承这两个类，问有派生类中多少个虚函数表？

如果不是虚继承的话即派生类没有重写虚函数，那么子类将父类的虚指针继承下来，并指向自身的虚表（发生在对象构造时）。有多少个虚函数，虚表里面的项就会有多少。多重继承时，可能存在多个的基类虚表与虚指针；

如果是虚继承的话，即派生类重写了虚函数，那么派生类会有两份虚指针，一份指向自己的虚表，另一份指向虚基表。多重继承时，虚基表与虚基表指针有且只有一份。

------

#### 八、覆盖、重载和隐藏的区别

**重载(overload)是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。**

- 同一个类中的同名成员函数才存在重载关系
- 这些函数的参数列表或返回类型不一样，从而实现了重载
- 重载和成员函数是否为虚函数无关

**覆盖(override)（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样，只是函数的实现体不一样。**

- 在派生类中覆盖基类的同名函数
- 基类函数为虚函数
- 两个函数的参数个数，参数类型，返回类型都相同

**隐藏(hide)是指派生类中的函数把基类中相同名字的函数屏蔽掉了。隐藏与另外两个概念表面上看来很像，很难区分，其实他们的关键区别就是在多态的实现上。**

- 派生类中的函数或成员屏蔽了基类中的同名函数或同名成员
- 隐藏和覆盖的区别：函数的参数相同，但是基类的函数不是虚函数(覆盖中基类的函数是虚函数)
- 隐藏和重载的区别：隐藏的概念是存在与两个不同的类中，即使两个函数参数不同，无论基类函数是否是虚函数，基类函数都会被屏蔽。
- 不仅能隐藏函数，也能隐藏数据成员。

------

#### 九、C++的设计模式

设计模式分为创建型设计模式、结构型设计模式和行为型设计模式。

单例模式是一种创建型的设计模式，保证一个类只有一个实例，并提供一个访问该实例的全局节点。通常运用在配置信息类、连接池类、ID生成器类等表示一些全局唯一类。单例模式的实现一般都是两个步骤，一个是将默认构造函数设置为私有，防止其他对象使用单例类的new运算符，第二个是创建一个静态构建方法作为构造函数，该函数调用构造函数来创建对象，并将其保存在一个静态成员变量中。之后所有对该函数的调用都将返回这一个缓存对象。(如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。日志系统需要服务器单例进行记录)

工厂模式也是一种创建型的设计模式，通过“对象创建”模式绕开new，使我们在创建对象的时候可以不依赖具体实例（所导致的紧耦合）。定义一个用于创建对象的接口，让子类决定实例化具体哪一个类，使得一个类的实例化进行延迟（解耦），将对象的创建和使用的过程分开。

原型模式也是一种创建型设计模式， 能够复制已有对象， 而又无需使代码依赖它们所属的类。

创建型的设计模式还有：生成器模式、抽象工厂模式

结构型的设计模式有：适配器模式、桥接模式、组合模式、代理模式、装饰模式、外观模式等

行为型设计模式：责任链模式、命令模式、迭代器模式、中介者模式、观察者模式、状态模式、策略模式等

#####1、单例模式

单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。

单例模式解决了两个问题：

- **保证一个类只有一个实例。**为什么会有人想要控制一个类所拥有的实例数量？ 最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。它的运作方式是这样的： 如果你创建了一个对象， 同时过一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。

- **为该实例提供一个全局访问节点**。 还记得你 （好吧， 其实是我自己） 用过的那些存储重要对象的全局变量吗？ 它们在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。

  和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。

  还有一点： 你不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此。

**所有单例的实现都包含以下两个相同的步骤：**

- 将默认构造函数设为私有， 防止其他对象使用单例类的 `new`运算符。
- 新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。

如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。

**单例模式适合应用的场景：**

- **如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。**

单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。

- **如果你需要更加严格地控制全局变量， 可以使用单例模式。**

 单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。

**实现方式：**

- 在类中添加一个私有静态成员变量用于保存单例实例。

- 声明一个公有静态构建方法用于获取单例实例。

- 在静态方法中实现"延迟初始化"。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。

- 将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。

- 检查客户端代码， 将对单例的构造函数的调用替换为对其静态构建方法的调用。

```c
class CSingleton
{
private:
	CSingleton(){}
    static CSingleton *m_pInstance;
public:
    static CSingleton * GetInstance()
    {
    	if(m_pInstance == NULL)
    		m_pInstance = new CSingleton();
    	return m_pInstance;
    }
}
```

**单例模式的优缺点：**

优：

- 可以保证一个类只有一个实例
- 获得了一个指向该实例的全局访问节点
- 仅在首次请求单例对象时对其进行初始化

缺：

- 违反了单一职责原则
- 该模式在多线程环境下需要进行特殊处理，避免多个线程多次创建单例对象。
- 单例模式可能掩盖不良设计，比如程序各组件之间相互了解过多。

#####2、工厂模式

**抽象工厂模式**是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。给一个抽象类，然后暴露出一个接口，在接口中给出一个具体类。

**目的：**

- 工厂模式让我们在创建对象的时候可以不依赖具体实例。而依赖抽象。当我们想要修改的时候，只要进行扩展即可。不需要修改。对扩展开放，对修改关闭
- 当创建对象是一个复杂的过程时，需要使用工厂方法。

**工厂模式的适用场景：**

- **如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。**

   抽象工厂为你提供了一个接口， 可用于创建每个系列产品的对象。 只要代码通过该接口创建对象， 那么你就不会生成与应用程序已生成的产品类型不一致的产品。

- **如果你有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。**

   在设计良好的程序中， *每个类仅负责一件事*。 如果一个类与多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。

**实现方式：**

1. 以不同的产品类型与产品变体为维度绘制矩阵。
2. 为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口。
3. 声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法。
4. 为每种产品变体实现一个具体工厂类。
5. 在应用程序中开发初始化代码。 该代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对象传递给所有需要创建产品的类。
6. 找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。

**工厂模式的优缺点：**

**优：**

-  可以确保同一工厂生成的产品相互匹配。
-  可以避免客户端和具体产品代码的耦合。
-  *单一职责原则*。 可以将产品生成代码抽取到同一位置， 使得代码易于维护。
-  *开闭原则*。 向应用程序中引入新产品变体时， 无需修改客户端代码。

**缺：**

- 由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。

------

#### 十、C++中的RTTI机制

RTTI是Runtime Type Identification的缩写，意思是运行时类型识别。C++引入这个机制是为了让程序在运行时能根据基类的指针或引用来获得该指针或引用所指的对象的实际类型。但是现在RTTI的类型识别已经不限于此了，它还能通过typeid操作符识别出所有的基本类型（int，指针等）的变量对应的类型。

C++通过以下的两个操作提供RTTI：

- typeid运算符，该运算符返回其表达式或类型名的实际类型。
- dynamic_cast运算符，该运算符将基类的指针或引用安全地转换为派生类类型的指针或引用。

------

#### 十一、STL顺序容器

- vector：可变大小数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢。
- deque：双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。
- list：双向链表。只支持双向顺序访问，在list中任何位置进行插入/删除操作速度都很快。
- forward_list：单向链表。只支持单项顺序访问，在链表任何位置进行插入/删除造作速度都很快。
- array：固定大小数组。支持快速随机访问，不能添加或删除元素。
- string：与vector相似得容器。但专门用于保存字符，随机访问快，在尾部插入删除快。

------

#### 十二、关联容器

关联容器中得元素是按关键字来保存和访问的。关联容器支持高效的关键字查找和访问，两个主要的关联容器是map和set。map中的元素是一些关键字--值对：关键字起到索引的作用，值则表示与索引相关联的数据。set中每个元素只包含一个关键字；标准库提供8个关联容器：

**按关键字有序保存元素：**

- map：关联数组；保存关键字-值对

- set：关键字即值，即保存关键字的容器

- multimap：关键字可重复出现的map
- multiset：关键字可重复出现的set

**无序集合：**

- unordered_map：用哈希函数组织的map
- unordered_set：用哈希函数组织的set
- unordered_multimap：哈希组织的map；关键字可以重复出现
- unordered_multiset：哈希组织的set；关键字可以重复出现

------

####十三、vector、list、deque、map和set的底层实现

- **vector**
  vector就是动态数组.它也是在堆中分配内存,元素连续存放,有保留内存,**如果减少大小后，内存也不会释放.如果新值>当前大小时才会再分配内存.**

  它拥有一段连续的内存空间，并且起始地址不变，因此它能非常好的支持随即存取，即[]操作符，**但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝**，另外，**当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。这些都大大影响了vector的效率。对最后元素操作最快(在后面添加删除最快 ), 此时一般不需要移动内存,只有保留内存不够时才需要**

- **list**
  list就是**双向链表**,**元素也是在堆中存放,**每个元素都是放在一块内存中,它的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的**随机存取变的非常没有效率**，因此它没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除和插入。

  list**没有空间预留习惯**，每次插入或者删除一个元素，就配置一个或释放一个元素空间。对于任何位置的元素插入或元素移除，list永远都是常熟时间。

- **deque**

  deque是一种双向开口的连续线性空间。所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作。vector当然也可以在头尾两端进行操作，但是头部操作效率奇差。

  deque允许于常数时间内对起头端进行元素的插入或移除操作，deque没有容量的概念，它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并连接起来。因此，deque没有必要提供所谓的空间保留（reserve）功能。

- **map**

  Map是关联容器，以键值对的形式进行存储，方便进行查找。关键词起到索引的作用，值则表示与索引相关联的数据。以红黑树的结构实现，插入删除等操作都在O(logn)时间内完成 

- **set**

  Set是关联容器，set中每个元素只包含一个关键字。set支持高效的关键字查询操作——检查一个给定的关键字是否在set中。set也是以红黑树的结构实现，支持高效插入、删除等操作。

#####请你讲讲STL有什么基本组成

 STL主要由：以下几部分组成：容器，迭代器，仿函数，算法分配器，配接器
他们之间的关系：分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数

#####C++ STL 的实现：

1.vector  底层数据结构为数组 ，支持快速随机访问

2.list    底层数据结构为双向链表，支持快速增删

3.deque   底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问

4.stack   底层一般用list,deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时

5.queue   底层一般用list,deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时

6.stack，queue是适配器,而不叫容器，因为是对容器的再封装

7.priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现

8.set       底层数据结构为红黑树，有序，不重复

9.multiset  底层数据结构为红黑树，有序，可重复 

10.map      ﻿﻿﻿﻿底层数据结构为红黑树，有序，不重复

11.multimap 底层数据结构为红黑树，有序，可重复

12.hash_set ﻿﻿﻿﻿底层数据结构为hash表，无序，不重复

13.hash_multiset 底层数据结构为hash表，无序，可重复 

14.hash_map      ﻿﻿﻿﻿底层数据结构为hash表，无序，不重复

15.hash_multimap 底层数据结构为hash表，无序，可重复

#### 十三、map和set有什么区别？

map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。

map和set区别在于：

（1）map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。

（2）set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。

（3）map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。

##### 红黑树

红黑树：是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。且符合以下性质：

1. 节点是红色或黑色。

2. 根节点是黑色。

3. 每个叶节点（NIL节点，空节点）是黑色的。

4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

这些约束保持了树的相对平衡，同时又比AVL的插入删除操作的复杂性要低许多。

##### 为什么要使用红黑树实现

为什么要用红黑树实现

map的场景本质上就是动态查找过程，所谓动态就是其中包含了插入和删除，并且数据量会比较大而且元素的结构也比较随意，并且都是基于内存来实现的，因此我们就需要考虑效率和成本，既要节约内存又要提高调整效率和查找速度。

红黑树优点：

1、首先红黑树是不符合AVL树的平衡条件的，即每个节点的左子树和右子树的高度最多差1的二叉查找树。但是提出了为节点增加颜色，红黑树是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。所以红黑树的插入效率更高

2、红黑树能够以O(log2 (n)) 的时间复杂度进行搜索、插入、删除操作

3、简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。



BST和AVL是二叉搜索树和平衡二叉树，这两个比较容易排除，BST可能退化成为链表，那么树就相当于很高，时间无法保证，AVL作为严格平衡的二叉搜索树对平衡性要求很高，因此在插入和删除数据时会造成不断地重度调整，影响效率，有点学术派而非工程派，但是AVL是后面很多变种树的基础也很重要，但是确实不适合用在map中。

Hash_Table其实目前已经有基于哈希表的map版本了，相比红黑树查找更快，然而时间的提升也是靠消耗空间完成的，哈希表需要考虑哈希冲突和装载因子的处理，在1994年左右内存很小并且很贵，因此哈希表在当时并没有被应用于实现map，现在内存相对来说已经很大并且不再昂贵，哈希表自然也有用武之地了。

Splay-Tree伸展树也是一种变种，它是一种能够自我平衡的二叉查找树，它能在均摊O(log n)的时间内完成基于伸展（Splay）操作的插入、查找、修改和删除操作。它是由丹尼尔·斯立特（Daniel Sleator）和罗伯特·塔扬在1985年发明的。

Treap就是Tree+heap，树堆也是一种二叉搜索树，是有一个随机附加域满足堆的性质的二叉搜索树，其结构相当于以随机数据插入的二叉搜索树。其基本操作的期望时间复杂度为O(log{n})。相对于其他的平衡二叉搜索树，Treap的特点是实现简单，且能基本实现随机平衡的结构。

B-Tree这里可以认为是B树族包括B树、B+树、B*树，我们都知道B树在MySQL索引中应用广泛，构建了更矮更胖的N叉树，这种结构结点可以存储更多的值，有数据块的概念，因此应对磁盘存储很有利，事实上即使内存中使用B树也可以提高CacheHit的成功率，从而提高效率，网上有的文章提到STL之父说如果再有机会他可能会使用B树来实现一种map，也就是借助于局部性原理来提高速度。



------

####十四、C++中的内存管理

在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。

代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。

数据段：存储程序中已初始化的全局变量和静态变量

bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。

堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。

映射区:存储动态链接库以及调用mmap函数进行的文件映射

栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值

------

####十五、STL里resize和reserve的区别

resize()：改变当前容器内含有元素的数量(size())，eg: vector<int>v; 

v.resize(len);v的size变为len,如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；
reserve()：改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存；

------

#### 十六、C++11有哪些新特性

- auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导
- nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。
- 智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。
- 初始化列表：使用初始化列表来对类进行初始化
- 右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率
- atomic原子操作用于多线程资源互斥操

------

#### 十七、右值引用

C++中，左值通常指可以取地址，有名字的值就是左值，而不能取地址，没有名字的就是右值。而在指C++11中，右值是由两个概念构成，将亡值和纯右值。纯右值是用于识别临时变量和一些不跟对象关联的值，比如1+3产生的临时变量值，2、true等，而将亡值通常是指具有转移语义的对象，比如返回右值引用T&&的函数返回值等。

基于右值引用可以实现转移语义和完美转发新特性。

**移动语义：**

对于一个包含指针成员变量的类，由于编译器默认的拷贝构造函数都是浅拷贝，所有我们一般需要通过实现深拷贝的拷贝构造函数，为指针成员分配新的内存并进行内容拷贝，从而避免悬挂指针的问题。C++使用移动构造函数，从而保证使用临时对象构造时不分配内存，从而提高性能。

将内存的所有权从一个对象转移到另外一个对象，高效的移动用来替换效率低下的复制，对象的移动语义需要实现移动构造函数（move constructor）和移动赋值运算符（move asssignment operator）。

**完美转发：**

完美转发是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另一个函数，即传入转发函数的是左值对象，目标函数就能获得左值对象，转发函数是右值对象，目标函数就能获得右值对象，而不产生额外的开销。

因此转发函数和目标函数参数一般采用引用类型，从而避免拷贝的开销。其次，由于目标函数可能需要能够既接受左值引用，又接受右值引用，所以考虑转发也需要兼容这两种类型。

------

####十八、C++中的atomic原子操作

它表示在多个线程访问同一个全局资源的时候，能够确保所有其他的线程都不在同一时间内访问相同的资源。也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。

在以往的C++标准中并没有对原子操作进行规定，我们往往是使用汇编语言，或者是借助第三方的线程库，例如intel的pthread来实现。在新标准C++11，引入了原子操作的概念，并通过这个新的头文件提供了多种原子操作数据类型，例如，atomic_bool,atomic_int等等，如果我们在多个线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的，也就是说，确保任意时刻只有一个线程对这个资源进行访问，编译器将保证，多个线程访问这个共享资源的正确性。从而避免了锁的使用，提高了效率。

------

#### 十九、深拷贝和浅拷贝

深拷贝，浅拷贝：当出现类的等号赋值时，即会调用拷贝函数

- C++在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。深拷贝指的就是当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象的另开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值。
- 深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。

------

#### 二十、构造函数为什么不能是虚函数，析构函数为什么是虚函数

##### 1、构造函数为什么不能是虚函数



从存储空间角度来说：虚函数是通过对象的内存空间的一张虚函数表和虚函数指针来调用的，而构造函数本身就是初始化实例，给对象分配内存空间。如果构造函数时虚函数的话，那么也需要通过虚函数表来进行调用，但是这时候对象的内存空间还没有，无法找到虚函数表，无法完成调用。所以构造函数不能是虚函数。

从实现上来看，构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，而虚函数是动态绑定。所以构造函数也没必要成为虚函数。





构造对象时需要知道对象的实际类型，而虚函数行为是在运行期间才能确定实际类型的，由于对象还未构造成功，编译器无法知道对象的实际类型，俨然是个鸡和蛋的问题。

如果构造函数是虚函数，那么构造函数的执行将依赖虚函数表，而虚函数表又是在构造函数中初始化的，而在构造对象期间，虚函数表又还没有被初始化，又是个死循环问题。

-  从存储空间角度，虚函数对应一个指向vtable虚函数表的指针，这大家都知道，可是这个指向vtable的指针其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。

-  从使用角度，虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。

-  从实现上看，vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有必要成为虚函数。

##### 2、虚析构

这是因为，通过基类指针来销毁派生类对象这个行为，当基类没有虚析构函数时会产生问题。我们知道删除指针对象是没有问题的，指针对象的析构函数会正确调用，但仅限于指针的类型所表示的对象大小。**如果以一个基类指针指向其派生类**，删除这个基类指针只能删除基类对象部分，而不能删除整个派生类对象，原因是通过基类指针无法访问派生类的析构函数。
但是，如果像其它虚函数一样，基类的析构函数也是虚的，那么派生类的析构函数也必然是虚的，删除基类指针时，它就会通过虚函数表找到正确的派生类析构函数并调用它，从而正确析构整个派生类对象。

------

#### 二十一、网络编程

##### socket阻塞和非阻塞、同步和异步  

网络IO的操作主要分为两个阶段，准备阶段和操作阶段。准备阶段是等待数据是否可用，在内核进程完成；操作阶段执行实际的IO调用，将数据从内核缓冲区拷贝到用户缓冲区。

**阻塞和非阻塞主要发生在第一阶段**，阻塞是指访问的数据如果没有准备就绪，当前线程会被挂起一直等待，等待数据准备就绪才继续下一个阶段，将数据拷贝到用户空间才返回；非阻塞是指访问的时候如果数据没有准备就绪，不会将线程挂起，会立即返回一个错误，然后当前线程会采用轮询的方式来检测数据是否准备好，如果准备好了，再进行下一个阶段，将数据拷贝到用户空间才返回。

**举个例子(阻塞)：**比如到你某个时候到A楼一层（假如是内核缓冲区）取快递，但是你不知道快递什么时候过来，你又不能干别的事，只能死等着。但你可以睡觉（进程处于休眠状态），因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。

**举个例子(非阻塞)：**还是如果用忙轮询的方法，每隔5分钟到A楼一层(内核缓冲区）去看快递来了没有。如果没来，立即返回。而快递来了，就放在A楼一层，等你去取。

**同步和异步主要发生在第二个阶段**，同步和异步是指访问数据的机制。同步一般指主动请求并等待数据从内核到用户空间的拷贝的IO操作，在未完成前，会导致当前线程被挂起，直到完成拷贝为止；异步是指用户触发IO操作以后便开始做自己的事情，而当数据拷贝的IO操作已经完成的时候会得到IO完成的通知，这可以使在读写数据时也不阻塞。

**同步IO和异步IO的区别就在于：数据访问的时候进程是否阻塞！**

**阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回！**

##### Linux下的五种I/O模型

- 阻塞I/O（blocking I/O）
- 非阻塞I/O （nonblocking I/O）
- I/O复用(select 和poll) （I/O multiplexing）
- 信号驱动I/O （signal driven I/O (SIGIO)）
- 异步I/O （asynchronous I/O (the POSIX aio_functions)）

前四种都是同步，只有最后一种才是异步IO。

**阻塞I/O模型**

使用阻塞模式的套接字，开发网络程序比较简单，容易实现。当希望能够立即发送和接收数据，且处理的套接字数量比较少的情况下，使用阻塞模式来开发网络程序比较合适。

阻塞模式套接字的不足表现为，在大量建立好的套接字线程之间进行通信时比较困难。当使用“生产者-消费者”模型开发网络程序时，为每个套接字都分别分配一个读线程、一个处理数据线程和一个用于同步的事件，那么这样无疑加大系统的开销。**其最大的缺点是当希望同时处理大量套接字时，将无从下手，其扩展性很差.**

阻塞模式给网络编程带来了一个很大的问题，如在调用 send()的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。这给多客户机、多业务逻辑的网络编程带来了挑战。

多线程的服务器模型似乎完美的解决了为多个客户机提供问答服务的要求，但其实并不尽然。如果要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而线程与进程本身也更容易进入假死状态。

由此可能会考虑使用“**线程池**”或“**连接池**”。“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如apache，mysql数据库等。

**非阻塞I/O**

非阻塞IO通过进程反复调用IO函数（多次系统调用，并马上返回）；在数据拷贝的过程中，进程是阻塞的；我们把一个SOCKET接口设置为非阻塞就是告诉内核，当所请求的I/O操作无法完成时，**不要将进程睡眠**，而是返回一个错误。这样我们的I/O操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。**在这个不断测试的过程中，会大量的占用CPU的时间。**

当使用socket()函数和WSASocket()函数创建套接字时，默认都是阻塞的。在创建套接字之后，通过调用ioctlsocket()函数，将该套接字设置为非阻塞模式。Linux下的函数是:fcntl().

非阻塞套接字在控制建立的多个连接，在数据的收发量不均，时间不定时，明显具有优势。这种套接字在使用上存在一定难度，但只要排除了这些困难，它在功能上还是非常强大的。通常情况下，可考虑使用套接字的“I/O模型”，它有助于应用程序通过异步方式，同时对一个或多个套接字的通信加以管理。

**IO复用模型**(同步，阻塞)

主要是select和epoll；对一个IO端口，两次调用，两次返回，比阻塞IO并没有什么优越性；关键是能实现同时对多个IO端口进行监听；

I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。  

![1.png](http://ww1.sinaimg.cn/large/0062FU9hly1gho52d4w6bj30st0j3jyi.jpg)

**信号驱动IO**

两次调用，两次返回；

首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。

![2.png](http://ww1.sinaimg.cn/large/0062FU9hly1gho53bumsjj30ru0hygs6.jpg)

**异步IO模型**

数据拷贝的时候进程无需阻塞。

当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者的输入输出操作

![3.png](http://ww1.sinaimg.cn/large/0062FU9hly1gho54xew0pj30qh0fy0xv.jpg)

**同步IO引起进程阻塞，直至IO操作完成。**
**异步IO不会引起进程阻塞。**
**IO复用是先通过select调用阻塞。**

**5个IO模型的比较**

![4.png](http://ww1.sinaimg.cn/large/0062FU9hly1gho56r6o5dj30rb0gd7b7.jpg)

#####IO复用

　IO多路复用使用两个系统调用(select/poll/epoll和recvfrom)，blocking IO只调用了recvfrom；select/poll/epoll 核心是可以同时处理多个connection，而不是更快，所以连接数不高的话，性能不一定比多线程+阻塞IO好,多路复用模型中，每一个socket，设置为non-blocking,阻塞是被select这个函数block，而不是被socket阻塞的。

**select机制：**
基本原理：
　　客户端操作服务器时就会产生这三种文件描述符(简称fd)：writefds(写)、readfds(读)、和exceptfds(异常)。select会阻塞住监视3类文件描述符，等有数据、可读、可写、出异常 或超时、就会返回；返回后通过遍历fdset整个数组来找到就绪的描述符fd，然后进行对应的IO操作。
优点：
　　几乎在所有的平台上支持，跨平台支持性好
缺点：
　　由于是采用轮询方式全盘扫描，会随着文件描述符FD数量增多而性能下降。
　　每次调用 select()，需要把 fd 集合从用户态拷贝到内核态，并进行遍历(消息传递都是从内核到用户空间)
　　默认单个进程打开的FD有限制是1024个，可修改宏定义，但是效率仍然慢。

**poll机制:**
　　基本原理与select一致，也是轮询+遍历；唯一的区别就是poll没有最大文件描述符限制（使用链表的方式存储fd）。

**epoll机制：**

基本原理：
　　没有fd个数限制，用户态拷贝到内核态只需要一次，使用时间通知机制来触发。通过epoll_ctl注册fd，一旦fd就绪就会通过callback回调机制来激活对应fd，进行相关的io操作。
epoll之所以高性能是得益于它的三个函数
　　1)epoll_create()系统启动时，在Linux内核里面申请一个B+树结构文件系统，返回epoll对象，也是一个fd
　　2)epoll_ctl() 每新建一个连接，都通过该函数操作epoll对象，在这个对象里面修改添加删除对应的链接fd, 绑定一个callback函数
　　3)epoll_wait() 轮训所有的callback集合，并完成对应的IO操作
优点：
　　没fd这个限制，所支持的FD上限是操作系统的最大文件句柄数，1G内存大概支持10万个句柄
　　效率提高，使用回调通知而不是轮询的方式，不会随着FD数目的增加效率下降
　　内核和用户空间mmap同一块内存实现(mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间)

- 首先来看看socket可读的条件.

一、下列四个条件中的任何一个满足时,socket准备好读: 
1. socket的接收缓冲区中的【已用】数据字节大于等于该socket的接收缓冲区低水位标记的当前大小。对这样的socket的读操作将不阻塞并返回一个大于0的值(也就是返回准备好读入的数据)。我们可以用SO_RCVLOWAT socket选项来设置该socket的低水位标记。对于TCP和UDP .socket而言，其缺省值为1.
2. 该连接的读这一半关闭(也就是接收了FIN的TCP连接)。对这样的socket的读操作将不阻塞并返回0
3.socket是一个用于监听的socket,并且已经完成的连接数为非0.这样的soocket处于可读状态,是因为socket收到了对方的connect请求,执行了三次握手的第一步:对方发送SYN请求过来,使监听socket处于可读状态;正常情况下,这样的socket上的accept操作不会阻塞;
4.有一个socket有异常错误条件待处理.对于这样的socket的读操作将不会阻塞,并且返回一个错误(-1),errno则设置成明确的错误条件.这些待处理的错误也可通过指定socket选项SO_ERROR调用getsockopt来取得并清除;

- 再来看看socket可写的条件.

二、下列三个条件中的任何一个满足时,socket准备好写: 
1. socket的发送缓冲区中的【剩余】数据字节大于等于该socket的发送缓冲区低水位标记的当前大小。对这样的socket的写操作将不阻塞并返回一个大于0的值(也就是返回准备好写入的数据)。我们可以用SO_SNDLOWAT socket选项来设置该socket的低水位标记。对于TCP和UDP socket而言，其缺省值为2048

2. 该连接的写这一半关闭。对这样的socket的写操作将产生SIGPIPE信号，该信号的缺省行为是终止进程。
3.有一个socket异常错误条件待处理.对于这样的socket的写操作将不会阻塞并且返回一个错误(-1),errno则设置成明确的错误条件.这些待处理的错误也可以通过指定socket选项SO_ERROR调用getsockopt函数来取得并清除;

##### select、poll、epoll简介

**select：**

select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：

- 单个进程可监视的fd数量被限制，即能监听端口的大小有限。 一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.
- 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。
- 需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大

**poll：**

poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。

它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：

- 大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。                                                                                                                               
- poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。

**epoll:**

epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就需态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知

epoll的优点：

- **没有最大并发连接的限制**，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；
- **效率提升**，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；
  即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。
- **内存拷贝**，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。

**select、poll、epoll 区别总结：**

1、支持一个进程所能打开的最大连接数

| select | 单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32*32，同理64位机器上FD_SETSIZE为32*64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。 |
| ------ | ------------------------------------------------------------ |
| poll   | poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的 |
| epoll  | 虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接 |

2、FD剧增后带来的IO效率问题

| select | 因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。 |
| ------ | ------------------------------------------------------------ |
| poll   | 同上                                                         |
| epoll  | 因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。 |

3、 消息传递方式

| select | 内核需要将消息传递到用户空间，都需要内核拷贝动作 |
| ------ | ------------------------------------------------ |
| poll   | 同上                                             |
| epoll  | epoll通过内核和用户空间共享一块内存来实现的。    |

**总结：**

综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。

- 表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。
- select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善

##### ET模式(边缘触发)和LT模式(水平触发)

水平触发：当采用水平触发通知时，我们可以在任意时刻检查文件描述符的就绪状态。这表示当我们确定了文件描述符处于就绪状态时（比如存在有输入数据），就可以对其执行一些I/O操作，然后重复检查文件描述符，看看是否仍然处于就绪态（比如还有更多的输入数据），此时我们就能执行更多的I/O。**比如说我们采用epoll水平触发模式监听一个文件描述符的可读，当这个文件可读就绪时，epoll会触发一个通知，然后我们执行一次读取操作，但这次操作我们并没有把该文件描述符的数据全部读取完。当下一次调用epoll监听该文件描述符时，epoll还会再次触发通知，直到该事件被处理完。这就意味着，当epoll触发通知后，我们可以不立即处理该事件，当下次调用epoll监听时，然后会再次向应用程序通告此事件，此时我们再处理也不晚。**

边沿触发：与之相反的是，当我们采用边沿触发时，只有当I/O事件发生时我们才会收到通知。**还是上个例子，如果这次我们采用epoll的边沿触发模式监听一个文件描述符的可读，当可读就绪时，epoll会触发一个通知，如果我们此时不立即处理该事件，当下次再调用epoll监听时，虽然该文件描述符的状态是可读的，但是此时epoll并不会再给应用程序发送通知。因为在边沿触发工作模式下，只有下一个新的I/O事件到来时，才会再次发送通知**。

下表是I/O多路复用select,poll和epoll所支持的通知模型：

| I/O模式  | 水平触发 | 边沿触发 |
| -------- | -------- | -------- |
| select() | 支持     | 不支持   |
| poll()   | 支持     | 不支持   |
| epoll()  | 支持     | 支持     |

select和poll只支持LT工作模式，epoll的默认的工作模式是LT模式。当往epoll内核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET模式来操作该文件描述符。

#### 二十二、排序算法

| 算法种类 |           | s时间复杂度 |           |            |          |
| -------- | --------- | ----------- | --------- | ---------- | -------- |
|          | 最好      | 平均        | 最坏      | 空间复杂度 | 是否稳定 |
| 插入排序 | O(n)      | O(n^2)      | O(n^2)    | O(1)       | 是       |
| 冒泡排序 | O(n)      | O(n^2)      | O(n^2)    | O(1)       | 是       |
| 选择排序 | O(n^2)    | O(n^2)      | O(n^2)    | O(1)       | 否       |
| 希尔排序 |           |             |           | O(1)       | 否       |
| 快速排序 | O(nlogn)  | O(nlogn)    | O(n^2)    | O(logn)    | 否       |
| 堆排序   | O(nlogn)  | O(nlogn)    | O(nlogn)  | O(1)       | 否       |
| 归并排序 | O(nlogn   | O(nlogn)    | O(nlogn)  | O(n)       | 是       |
| 基数排序 | O(d(n+r)) | O(d(n+r))   | O(d(n+r)) | O(r)       | 是       |

#### 二十三、socket编程调用的API

服务器端的主要步骤：(Win)

- WSAStartup：初始化socket库(Winsock)
- WSACleanup:清除/终止socket库的使用(WinSock)
- socket:创建套接字
- connect：”连接“远程服务器(仅用于客户端)
- closesocket：释放/关闭套接字
- bind：绑定套接字的本地IP地址和端口号(通常客户端不需要)
- listen：置服务器端TCP套接字为监听模式，并设置队列大小(仅用于服务器端TCP套接字)
- accept：接受/提取一个连接请求，创建新套接字(仅用于服务器端的TCP套接字)
- recv：接收数据(用于TCP套接字或连接模式的客户端套接字)

linux:服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。



#### 二十四、extern C的作用

extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般之包括函数名。 

这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern "C"就是其中的一个策略。 