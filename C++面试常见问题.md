###C++面试常见问题

####一、C/C++中static关键字的作用

- **C面向过程的static关键字：**

**1、静态全局变量：**在全局变量前加上关键字static，该变量就被定义成为一个静态全局变量。

静态全局变量有以下特点：
• 该变量在全局数据区分配内存；
• 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；
• 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；　

**代码区**
**全局数据区**
**堆区**
**栈区**

一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。

**2、静态局部变量：**在局部变量前加上关键字static，该变量就被定义成为一个静态局部变量。

静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。

静态局部变量有以下特点：
• 该变量在全局数据区分配内存；
• 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
• 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；
• 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；

**3、静态函数：**在函数的返回类型前加上static关键字，函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。

定义静态函数的好处：
• 静态函数不能被其它文件所用；
• 其它文件中可以定义相同名字的函数，不会发生冲突；

- **C++面向对象的static关键字：**

**1、类静态数据成员：**在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。

• 对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；
• 静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。
• 静态数据成员和普通数据成员一样遵从public,protected,private访问规则；
• 因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；
• 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：
＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞
• 类的静态数据成员有两种访问形式：
＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞
如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ；
• 静态数据成员主要用在各个对象都有相同的某项属性的时候。
• 同全局变量相比，使用静态数据成员有两个优势：

1. 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；
2. 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；

**2、类静态成员函数：**与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。

关于静态成员函数，可以总结为以下几点：
• 出现在类体外的函数定义不能指定关键字static；
• 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；
• 非静态成员函数可以任意地访问静态成员函数和静态数据成员；
• 静态成员函数不能访问非静态成员函数和非静态数据成员；
• 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；
• 调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：＜类名＞::＜静态成员函数名＞（＜参数表＞）调用类的静态成员函数。

####二、C和C++的区别：

**1、语言**

- C语言是面向过程的语言，是具体化，流程化的，解决一个问题，需要一步一步的分析，一步一步的实现；

- C++是模型化的，你只要抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以，不必一步一步去实现；

**2、宏与模板**

C++ 的模板在设计之初的一个用途就是用来替换宏定义。模板不同于宏的文字替换，在编译时会得到更全面的编译器检查，便于编写更健全的代码，利用 inline 关键字还能获得编译器充分的优化。

**3、struct和class**

C 中的 struct 用来描述一种固定的内存组织结构，而 C++ 中的 struct 就是一种类， **它与类唯一的区别就是它的成员和继承行为默认是 public 的** ，而一般类的默认成员是 private 的。

4、C++ 对 C 的增强，表现在六个方面：

- 增强了类型检查机制
- 增加了面向对象的机制
- 增加了泛型编程的机制（template）
- 增加了异常处理
- 增加了重载的机制
- 增加了标准模板库（STL）

####三、C++中的类型转化：

**C++类型转换大体上包括隐式类型转换和显式类型转换。**

**1、隐式类型转化**

隐式类型转换是自动执行的，无需显式的操作符。 隐式类型转换发生在很多地方，比如函数实参到形参的类型转换、函数返回值类型的自动转换等等。

**1.1、数值类型转化：**从小整数类型(char、short)转换到int，或者从float转换到double，这种“提升型”的转换通常不会造成数值差异。

**1.2、指针类型转化：**指针通常存在以下转换：

- 空指针可以转换到任意指针类型；
- 任意指针类型都可以转换到void* 指针；
- 继承类指针可以转换到可访问的明确的基类指针， 同时不改变const或者volatile属性;
- 一个C风格的数组隐式把数组的第一个元素转换为一个指针。

**2、显示类型转化**

**2.1、explicit关键字：**C++提供了关键字explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生。即声明为explicit的构造函数不能在隐式转换中使用。	

**2.2、强制类型转化：**

**2.2.1、static_cast**：

```
static_cast <new_type> (expression)
```

**static_cast强制转换只会在编译时检查，但没有运行时类型检查来保证转换的安全性。所以这类型的强制转换和C语言风格的强制转换都有安全隐患。**主要应用场景：

- 用于类层次结构中基类和子类之间指针或引用的转换。进行上行转换（把子类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成子类指针或引用）时，由于没有动态类型检查，所以是不安全的。
- 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
- 把void指针转换成目标类型的指针(不安全!!)
- 把任何类型的表达式转换成void类型
- 将enum class值转化为整数或者浮点数
- 转换为右值引用

**2.2.2、const_cast:**

```
const_cast <new_type> (expression)
```

new_type 必须是一个指针、引用或者指向对象类型成员的指针。**const_cast用于去除除对象的const或者volatile属性。**

- 常量指针被转化成非常量的指针，并且仍然指向原来的对象；
- 常量引用被转换成非常量的引用，并且仍然指向原来的对象；
- const_cast一般用于修改指针。如const char *p形式。

**2.2.3、dynamic_cast:**

```
dynamic_cast <new_type> (expression)
```

**dynamic_cast 在运行时执行转换，验证转换的有效性。**new_type 必须是一个指针或引用或“指向 void 的指针”。 如果 new_type 是指针，则expression 的类型必须是指针，如果 type-id 是引用，则expression为左值。 如果转型失败会返回null（转型对象为指针时）或抛出异常（转型对象为引用时)。dynamic_cast 会动用运行时信息（RTTI）来进行类型安全检查，因此dynamic_cast 存在一定的效率损失。

dynamic_cast 的一个重要作用就是要确保转换结果应该指向一个完整的目标类型。此外，dynamic_cast只有在基类存在虚函数(虚函数表)的情况下才有可能将基类指针转化为子类。

**2.2.4、reinterpret_cast：**

```
reinterpret_cast <new_type> (expression)
```

**reinterpret_cast 运算符把某种指针改为其他类型的指针。它可以把一个指针转换为一个整数，也可以把一个整数转换为一个指针。**new_type必须是一个指针、引用、算术类型、函数指针或者成员指针。其转换结果与编译平台息息相关，不具有可移植性，因此在一般的代码中不常见到它。**reinterpret_cast 常用的一个用途是转换函数指针类型，即可以将一种类型的函数指针转换为另一种类型的函数指针，但这种转换可能会导致不正确的结果。**

#### 四、C++中的四个智能指针

**1、为什么要使用智能指针？**

如果一块内存被多个指针引用，但其中的一个指针释放且其余的指针并不知道，这样的情况下，就发生了挂起引用。而内存泄露，就如你知道的一样，当从堆中申请了内存后不释放回去，这时就会发生内存泄露。使用智能指针可以很大程度上避免这个问题，智能指针是一个`RAII`（`Resource Acquisition is initialization`）类模型，用来动态的分配内存。它提供所有普通指针提供的接口，却很少发生异常。在构造中，它分配内存，当离开作用域时，它会自动释放已分配的内存。

**2、四个智能指针：**

- **auto_ptr**:**auto_ptr这个智能指针在新的C++11标准中已经不太常用**，它有以下几个问题：

  1、**当把一个auto_ptr赋给另外一个auto_ptr时，它的所有权(ownship)也转移了。**当我在函数间传递`auto_ptr`时，这就是一个问题。例如，我在`Foo()`中有一个`auto_ptr`，然后在`Foo()`中我把指针传递给了`Fun()`函数，当`Fun()`函数执行完毕时，指针的所有权不会再返还给`Foo`。

  2、**auto_ptr不能指向一组对象，就是说他不能和操作符new[]一起使用。**因为当`auto_ptr`离开作用域时，`delete`被默认用来释放关联的内存空间。

  3、**auto_ptr不能和标准容器（vector,list,map……）一起使用**

- **shared_ptr：shared_ptr共享所有权。可以被多个指针共享，多个指针可以同时指向一个对象，当最后一个shared_ptr离开作用域时，内存才会自动释放。**

  **创建：**尽量使用make_shared宏来加速创建的过程。make_shared以一种更有效率的方法来实现创建工作。可以通过调用use_count()得到资源的引用计数，找到shared_ptr的数量。

  **析构**：shared_ptr默认调用delete释放关联的资源。如果用户采用一个不一样的析构策略时，他可以自由指定构造这个shared_ptr的策略。比如：shared_ptr指向一组对象，但是当离开作用域时，默认的析构函数调用delete释放资源。实际上，我们应该调用delete[]来销毁这个数组。用户可以通过调用一个函数，例如一个lamda表达式，来指定一个通用的释放步骤。

  ```
  shared_ptr<Test> sptr1( new Test[5], [ ](Test* p) { delete[ ] p; } );
  ```

  **接口：**就像一个普通指针一样，shared_ptr也提供解引用操作符*,->。除此之外，它还提供了一些更重要的接口：

  -  `get()`: 获取`shared_ptr`绑定的资源.
  -  `reset()`: 释放关联内存块的所有权，如果是最后一个指向该资源的`shared_ptr`,就释放这块内存。
  -  `unique`: 判断是否是唯一指向当前内存的`shared_ptr`.
  -  `operator bool` : 判断当前的`shared_ptr`是否指向一个内存块，可以用if 表达式判断。
  - release():当前指针会释放资源所有权，计数减一。

  **存在的问题：**

  - 如果几个`shared_ptrs`指向的内存块属于不同组，将产生错误。

  - 如果从一个普通指针创建一个`shared_ptr`还会引发另外一个问题。

  - 循环引用：如果共享智能指针卷入了循环引用，资源都不会正常释放

- **weak_ptr:**weak_ptr用来解决shared_ptr循环引用的的问题。`weak_ptr` 拥有共享语义和不包含语义。这意味着，`weak_ptr`可以共享`shared_ptr`持有的资源。所以可以从一个包含资源的`shared_ptr`创建`weak_ptr`。

  **创建**:可以以`shared_ptr`作为参数构造`weak_ptr`.从`shared_ptr`创建一个`weak_ptr`增加了共享指针的弱引用计数，意味着`shared_ptr`与其它的指针共享着它所拥有的资源。但是当`shared_ptr`离开作用域时，这个计数不作为是否释放资源的依据。换句话说，就是除非强引用计数变为`0`，才会释放掉指针指向的资源，

  如何判断`weak_ptr`是否指向有效资源，有两种方法：

  1. 调用`use-count()`去获取引用计数，该方法只返回强引用计数，并不返回弱引用计数。
  2. 调用`expired()`方法。比调用`use_count()`方法速度更快。

  从`weak_ptr`调用`lock()`可以得到`shared_ptr`或者直接将`weak_ptr`转型为`shared_ptr`

- **unique_ptr:**`unique_ptr`也是对`auto_ptr`的替换。`unique_ptr`遵循着独占语义。在任何时间点，资源只能唯一地被一个`unique_ptr`占有。当`unique_ptr`离开作用域，所包含的资源被释放。如果资源被其它资源重写了，之前拥有的资源将被释放。所以它保证了他所关联的资源总是能被释放。

  **创建：**unique_ptr的创建方法和shared_ptr一样，但是unique_ptr提供了创建数组对象的特殊方法，当指针离开作用域时，调用delete[]代替delete。当创建unique_ptr时，这一组对象被视作模板参数的部分。

  当把`unique_ptr`赋给另外一个对象时，资源的所有权就会被转移。

  `unique_ptr`不提供复制语义（拷贝赋值和拷贝构造都不可以），只支持移动语义(`move semantics`).

####五、指针和引用的区别

**指针和引用主要有以下区别：**

- 引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。

- 引用初始化后不能被改变，指针可以改变所指的对象。

- 不存在指向空值的引用，但是存在指向空值的指针。

从概念上讲。指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。

而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。

- 指针是一个实体，而引用仅是个别名；

- 引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；

- **引用没有const，指针有const，const的指针不可变**；

- **引用不能为空，指针可以为空**；

- “**sizeof 引用**”得到的是所指向的变量(对象)的大小，而“**sizeof 指针**”得到的是指针本身的大小；

- 指针和引用的自增(++)运算意义不一样；

- 引用是类型安全的，而指针不是 (引用比指针多了类型检查）

#### 六、C++虚函数机制

C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要再派生类中声明该方法为虚方法。

- 虚表指针vptr(只要基类有虚函数)，具体存在位置因编译器而定。

- 虚表指针指向虚表。虚表中动态绑定虚函数
- 类的非虚函数是静态的。地址不变，虚函数则是动态绑定。即如果子类重写了虚函数，就指向自己的虚函数地址。否则指向基类该函数的地址。

如果使用了**virtual**关键字，程序将根据**引用或指针**指向的 **对 象 类 型** 来选择方法，否则使用**引用类型或指针类型**来选择方法。

虚函数的实现是通过虚函数表+虚表指针来实现的。编译器为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针(vptr)，这种数组成为虚函数表。即，每个类使用一个虚函数表，每个类对象使用一个虚表指针。

**基类对象包含一个虚表指针，指向基类中所有虚函数的地址表。派生类对象也将包含一个虚表指针，指向派生类虚函数表**。*看下面两种情况：*

- 如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址。
- 如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。

#### 七、覆盖、重载和隐藏的区别

**重载(overload)是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。**

- 同一个类中的同名成员函数才存在重载关系
- 这些函数的参数列表或返回类型不一样，从而实现了重载
- 重载和成员函数是否为虚函数无关

**覆盖(override)（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样，只是函数的实现体不一样。**

- 在派生类中覆盖基类的同名函数
- 基类函数为虚函数
- 两个函数的参数个数，参数类型，返回类型都相同

**隐藏(hide)是指派生类中的函数把基类中相同名字的函数屏蔽掉了。隐藏与另外两个概念表面上看来很像，很难区分，其实他们的关键区别就是在多态的实现上。**

- 派生类中的函数或成员屏蔽了基类中的同名函数或同名成员
- 隐藏和覆盖的区别：函数的参数相同，但是基类的函数不是虚函数(覆盖中基类的函数是虚函数)
- 隐藏和重载的区别：隐藏的概念是存在与两个不同的类中，即使两个函数参数不同，无论基类函数是否是虚函数，基类函数都会被屏蔽。
- 不仅能隐藏函数，也能隐藏数据成员。

#### 八、C++的设计模式

####1、单例模式

单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。

单例模式解决了两个问题：

- **保证一个类只有一个实例。**为什么会有人想要控制一个类所拥有的实例数量？ 最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。它的运作方式是这样的： 如果你创建了一个对象， 同时过一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。

- **为该实例提供一个全局访问节点**。 还记得你 （好吧， 其实是我自己） 用过的那些存储重要对象的全局变量吗？ 它们在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。

  和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。

  还有一点： 你不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此。

**所有单例的实现都包含以下两个相同的步骤：**

- 将默认构造函数设为私有， 防止其他对象使用单例类的 `new`运算符。
- 新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。

如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。

**单例模式适合应用的场景：**

- **如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。**

单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。

- **如果你需要更加严格地控制全局变量， 可以使用单例模式。**

 单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。

**实现方式：**

- 在类中添加一个私有静态成员变量用于保存单例实例。

- 声明一个公有静态构建方法用于获取单例实例。

- 在静态方法中实现"延迟初始化"。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。

- 将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。

- 检查客户端代码， 将对单例的构造函数的调用替换为对其静态构建方法的调用。

```c
class CSingleton
{
private:
	CSingleton(){}
    static CSingleton *m_pInstance;
public:
    static CSingleton * GetInstance()
    {
    	if(m_pInstance == NULL)
    		m_pInstance = new CSingleton();
    	return m_pInstance;
    }
}
```

**单例模式的优缺点：**

优：

- 可以保证一个类只有一个实例
- 获得了一个指向该实例的全局访问节点
- 仅在首次请求单例对象时对其进行初始化

缺：

- 违反了单一职责原则
- 该模式在多线程环境下需要进行特殊处理，避免多个线程多次创建单例对象。
- 单例模式可能掩盖不良设计，比如程序各组件之间相互了解过多。

####2、工厂模式

**抽象工厂模式**是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。给一个抽象类，然后暴露出一个接口，在接口中给出一个具体类。

**目的：**

- 工厂模式让我们在创建对象的时候可以不依赖具体实例。而依赖抽象。当我们想要修改的时候，只要进行扩展即可。不需要修改。对扩展开放，对修改关闭
- 当创建对象是一个复杂的过程时，需要使用工厂方法。

**工厂模式的适用场景：**

- **如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。**

   抽象工厂为你提供了一个接口， 可用于创建每个系列产品的对象。 只要代码通过该接口创建对象， 那么你就不会生成与应用程序已生成的产品类型不一致的产品。

- **如果你有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。**

   在设计良好的程序中， *每个类仅负责一件事*。 如果一个类与多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。

**实现方式：**

1. 以不同的产品类型与产品变体为维度绘制矩阵。
2. 为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口。
3. 声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法。
4. 为每种产品变体实现一个具体工厂类。
5. 在应用程序中开发初始化代码。 该代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对象传递给所有需要创建产品的类。
6. 找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。

**工厂模式的优缺点：**

**优：**

-  可以确保同一工厂生成的产品相互匹配。
-  可以避免客户端和具体产品代码的耦合。
-  *单一职责原则*。 可以将产品生成代码抽取到同一位置， 使得代码易于维护。
-  *开闭原则*。 向应用程序中引入新产品变体时， 无需修改客户端代码。

**缺：**

- 由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。

####九、C++中的RTTI机制

RTTI是Runtime Type Identification的缩写，意思是运行时类型识别。C++引入这个机制是为了让程序在运行时能根据基类的指针或引用来获得该指针或引用所指的对象的实际类型。但是现在RTTI的类型识别已经不限于此了，它还能通过typeid操作符识别出所有的基本类型（int，指针等）的变量对应的类型。

C++通过以下的两个操作提供RTTI：

- typeid运算符，该运算符返回其表达式或类型名的实际类型。
- dynamic_cast运算符，该运算符将基类的指针或引用安全地转换为派生类类型的指针或引用。

十、STL顺序容器

- vector：可变大小数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢。
- deque：双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。
- list：双向链表。只支持双向顺序访问，在list中任何位置进行插入/删除操作速度都很快。
- forward_list：单向链表。只支持单项顺序访问，在链表任何位置进行插入/删除造作速度都很快。
- array：固定大小数组。支持快速随机访问，不能添加或删除元素。
- string：与vector相似得容器。但专门用于保存字符，随机访问快，在尾部插入删除快。

十一、关联容器

关联容器中得元素是按关键字来保存和访问的。关联容器支持高效的关键字查找和访问，两个主要的关联容器是map和set。map中的元素是一些关键字--值对：关键字起到索引的作用，值则表示与索引相关联的数据。set中每个元素只包含一个关键字；标准库提供8个关联容器：

按关键字有序保存元素：

- map：关联数组；保存关键字-值对

- set：关键字即值，即保存关键字的容器

- multimap：关键字可重复出现的map
- multiset：关键字可重复出现的set

无序集合：

- unordered_map：用哈希函数组织的map
- unordered_set：用哈希函数组织的set
- unordered_multimap：哈希组织的map；关键字可以重复出现
- unordered_multiset：哈希组织的set；关键字可以重复出现

十二、封装、继承和多态

面向对象的三个基本特征是：封装、继承、多态。其中，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！

1、封装

封装可以隐藏实现细节，使得代码模块化；封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。在面向对象编程上可理解为：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

2、继承

继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。其继承的过程，就是从一般到特殊的过程。

通过继承创建的类称为子类或者派生类，被继承的类叫做父类或者基类。一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。

继承概念的实现方式有三类：实现继承、接口继承和可视继承。

- 实现继承是指使用基类的属性和方法而无需额外编码的能力；

- 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；

- 可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。

3、多态

多态允许将子类类型的指针赋值给父类类型的指针，可以简单地概括为“一个接口，多种方法”，程序在运行时才决定要调用的函数。

多态有两种实现方式，覆盖和重载。

C++的多态性是通过虚函数来实现的，虚函数允许派生类重新定义成员函数，而派生类重新定义基类的做法称为覆盖，或者称为重写。（重写的话可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性）

而重载则是允许有多个同名的函数，而这些函数的参数列表不同，允许参数个数不同，参数类型不同，或者两者都不同。

十三、select、poll和epoll
select：

select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：

- 单个进程可监视的fd数量被限制，即能监听端口的大小有限。 一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.

- 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。

- 需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大

poll：

poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。

它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：

- 大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。                                                                                                                               
- poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。

epoll:

epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就需态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知

epoll的优点：

- 没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；
- 效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；
即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。
- 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。

select、poll、epoll 区别总结：

1、支持一个进程所能打开的最大连接数

  select	单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是3232，同理64位机器上FD_SETSIZE为3264），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。
  poll  	poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的
  epoll 	虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接

2、FD剧增后带来的IO效率问题

  select	因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。
  poll  	同上                                      
  epoll 	因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。

3、 消息传递方式

  select	内核需要将消息传递到用户空间，都需要内核拷贝动作 
  poll  	同上                       
  epoll 	epoll通过内核和用户空间共享一块内存来实现的。

总结：

综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。

- 表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。

- select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善

