### 项目

#### 恶意软件检测系统研究

这个项目是一个学术研究性质的一个项目，主要是研究Android下的恶意软件的检测。使用genymotion安卓模拟器，动态运行apk文件；使用ebpf工具动态监控运行的apk文件，从而获得恶意软件内核底层的相关行为特征；使用特征选择方法，进行数据处理，消除冗余特征；再使用机器学习分类算法进行分类训练。形成一个区别恶意软件和正常软件的分类器，到达检测恶意软件的目的，根据定义的相关指标得出检测效果。

**主要负责：**行为特征数据处理和分类训练检测。直接使用特征集作分类检测，检测效率和准确率稍低，使用特征选择方法卡方检验+主成分分析法对数据集进行处理，降低特征集维度，消除冗余特征。再进行分类测试。

1、伯克利包过滤器（Berkeley Packet Filter，缩写 BPF）是类 Unix 系统上数据链路层的一种原始接口，提供过滤报的方法。从 3.18 版本开始，Linux 内核提供了一种扩展的 BPF 虚拟机，被称为“extended BPF”，简称为 eBPF。它能够被用于非网络相关的功能，从而获取当前内核运行的许多信息 。

**应用：**eBPF 程序可以被设计用于各种各样的情形下，其分为两个应用领域。其中一个应用领域是内核跟踪和事件监控。BPF 程序可以被附着到静态 tracepoints 上或者动态探针（kprobe） 上，而且它与其它跟踪模式相比，有很多的优点。

另外一个应用领域是网络编程。除了套接字过滤器外，eBPF 程序还可以附加到 tc（Linux 流量控制工具）的入站或者出站接口上，以一种很高效的方式去执行各种包处理任务。

**安全性：**eBPF 不需要陷入内核便可通过编写函数从用户态获取内核态的相关数据，减少了陷入内核的消耗。eBPF 也是加强了在和用户空间交互的安全性。在内核中的检测器会拒绝加载引用了无效指针的字节码或者是以达到最大栈大小限制。循环也是不允许的（除非在编译时就知道是有常数上线的循环），字节码只能够调用一小部分指定的 eBPF 帮助函数。

使用 eBPF 提取内核更底层的特征，如内核函数调用、CPU 利用率等特征，网络流量、文件访问等特征
用机器学习算法进行分类检测。提高检测的效率，准确率，减少系统的资源消耗。

2、对通过ebpf拿到的一些数据做数据处理，拿到的数据中可能有些是对分类没有贡献，反而影响分类结果的特征，使用特征选择对拿到的数据，进行数据集降维，消除相关特征冗余。保证数据集的有效性和可靠性。

3、使用四种机器学习分类算法对数据集进行训练，定义评价指标，准确率、效率、误报率等，根据最终的分类结果，计算出评价指标。对比各种分类算法，得出最适合恶意软件检测的分类算法，最终进行分类检测。



####Linux下轻量级web服务器

该项目是Linux下C++轻量级Web服务器的实现。使用线程池 +非阻塞socket + epoll+事件处理的并发模型；使用状态机解析HTTP请求报文，⽀持解析GET和POST请求；访问服务器数据库实现web端用户注册、登录功能，可以请求服务器图片和视频文件；实现同步/异步日志系统，记录服务器运行状态。

**主要负责：**访问服务器数据库的实现和日志系统的实现。

阻塞I/O

使用阻塞模式的套接字，开发网络程序比较简单，容易实现。当希望能够立即发送和接收数据，且处理的套接字数量比较少的情况下，使用阻塞模式来开发网络程序比较合适。

阻塞模式套接字的不足表现为，在大量建立好的套接字线程之间进行通信时比较困难。当使用“生产者-消费者”模型开发网络程序时，为每个套接字都分别分配一个读线程、一个处理数据线程和一个用于同步的事件，那么这样无疑加大系统的开销。其最大的缺点是当希望同时处理大量套接字时，将无从下手，其扩展性很差.

阻塞模式给网络编程带来了一个很大的问题，如在调用 send()的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。这给多客户机、多业务逻辑的网络编程带来了挑战。

多线程的服务器模型似乎完美的解决了为多个客户机提供问答服务的要求，但其实并不尽然。如果要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而线程与进程本身也更容易进入假死状态。

由此可能会考虑使用“**线程池**”或“**连接池**”。“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如apache，mysql数据库等。

非阻塞I/O

非阻塞IO通过进程反复调用IO函数（多次系统调用，并马上返回）；在数据拷贝的过程中，进程是阻塞的；我们把一个SOCKET接口设置为非阻塞就是告诉内核，当所请求的I/O操作无法完成时，**不要将进程睡眠**，而是返回一个错误。这样我们的I/O操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。在这个不断测试的过程中，会大量的占用CPU的时间。



数据库模块:

单例模式，保证唯一

list实现连接池

连接池为静态大小

互斥锁实现线程安全

HTTP请求采用POST方式

\> * 登录用户名和密码校验

\> * 用户注册及多线程注册安全



根据状态转移,通过主从状态机封装了http连接类。其中,主状态机在内部调用从状态机,从状态机将处理状态和数据传给主状态机

\> * 客户端发出http连接请求

\> * 从状态机读取数据,更新自身状态和接收数据,传给主状态机

\> * 主状态机根据从状态机状态,更新自身状态,决定响应请求还是继续读取



日志模块：同步/异步日志系统主要涉及了两个模块，一个是日志模块，一个是阻塞队列模块,其中加入阻塞队列模块主要是解决异步写入日志做准备.

\> * 自定义阻塞队列

\> * 单例模式创建日志

\> * 同步日志

\> * 异步日志

\> * 实现按天、超行分类

\



半同步/半反应堆线程池

使用一个工作队列完全解除了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它。

\> * 同步I/O模拟proactor模式

\> * 半同步/半反应堆

\> * 线程池