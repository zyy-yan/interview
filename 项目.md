### 项目

#### 恶意软件检测系统研究

这个项目是一个学术研究性质的一个项目，主要是研究Android下的恶意软件的检测。使用genymotion安卓模拟器，动态运行apk文件；使用ebpf工具动态监控运行的apk文件，从而获得恶意软件内核底层的相关行为特征；使用特征选择方法，进行数据处理，消除冗余特征；再使用机器学习分类算法进行分类训练。形成一个区别恶意软件和正常软件的分类器，到达检测恶意软件的目的，根据定义的相关指标得出检测效果。

该项目主要是研究Android下的恶意软件的检测，判断apk文件是否带有病毒。使用genymotion安卓模拟器，动态运行apk文件；使用ebpf工具动态监控运行的apk文件，从而获得恶意软件内核底层的相关行为特征；使用特征选择方法，进行数据处理，消除冗余特征；再使用机器学习分类算法进行分类训练。形成一个区别恶意软件和正常软件的分类器，达到	检测恶意软件的目的，根据定义的相关指标得出检测效果。

**主要负责：**行为特征数据处理和分类训练检测。直接使用特征集作分类检测，检测效率和准确率稍低，使用特征选择方法卡方检验+主成分分析法对数据集进行处理，降低特征集维度，消除冗余特征。再进行分类测试。



这个项目是一个学术研究性质的一个项目，主要是研究Android下的恶意软件的检测，判断一个APK文件是否是恶意软件还是正常软件。

项目主要分为三个大模块：第一个是特征提取

首先使用genymotion安卓模拟器运行apk文件，然后通过监控apk文件在内核下的行为，获取相应的行为特征。由于内核中的一些数据要拿到，比如内核函数的调用、CPU利用率计算的各个指标，网路流量等特征，可能需要写一个内核模块，插入到内核中，通过运行内核模块拿到相关数据。这样比较麻烦，耗时。这个项目采用了一种新技术ebpf技术。eBPF支持在用户态将C语言编写的一小段“内核代码”注入到内核中运行，注入时要先用llvm编译得到使用BPF指令集的elf文件，然后从elf文件中解析出可以注入内核的部分，最后用bpf_load_program方法完成注入。 用户态程序和注入到内核中的程序通过共用一个位于内核中`map`实现通信。为了防止注入的代码导致内核崩溃，eBPF会对注入的代码进行严格检查，拒绝不合格的代码的注入。BCC是一个python库，实现了map创建、代码编译、解析、注入等操作，使开发人员只需聚焦于用C语言开发要注入的内核代码。通过使用BCC工具获取相关特征。

第二个模块是：特征选择

这个模块主要是对所拿到的特征数据做个特征选择，因为拿到的数据过多，而且有些数据特征对分类没有作用，反而会影响分类训练的效果，所以要对数据集及逆行处理。主要是采用主成分分析和卡方检验对特征集进行数据处理，消除冗余特征，降低特征集的维度，增加特征集的可靠性和代表性。

第三个模块是：分类检测

将处理完的数据集导入weka工具中，采用不同的分类算法对数据集进行分类训练，这里采用是折交叉验证的方式来进行测试，就是将数据集分为10份，9份作为训练集，1份作为测试集，不断轮询。进行测试，通过分类指标来判断算法的检测效果，最终得出分类效果较好的算法，实现恶意软件的检测。





eBPF支持在用户态将C语言编写的一小段“内核代码”注入到内核中运行，注入时要先用llvm编译得到使用BPF指令集的elf文件，然后从elf文件中解析出可以注入内核的部分，最后用bpf_load_program方法完成注入。 用户态程序和注入到内核中的程序通过共用一个位于内核中`map`实现通信。为了防止注入的代码导致内核崩溃，eBPF会对注入的代码进行严格检查，拒绝不合格的代码的注入。

BCC是一个python库，实现了map创建、代码编译、解析、注入等操作，使开发人员只需聚焦于用C语言开发要注入的内核代码。

**应用：**eBPF 程序可以被设计用于各种各样的情形下，其分为两个应用领域。其中一个应用领域是内核跟踪和事件监控。BPF 程序可以被附着到静态 tracepoints 上或者动态探针（kprobe） 上，而且它与其它跟踪模式相比，有很多的优点。

另外一个应用领域是网络编程。除了套接字过滤器外，eBPF 程序还可以附加到 tc（Linux 流量控制工具）的入站或者出站接口上，以一种很高效的方式去执行各种包处理任务。

**安全性：**eBPF 不需要陷入内核便可通过编写函数从用户态获取内核态的相关数据，减少了陷入内核的消耗。eBPF 也是加强了在和用户空间交互的安全性。在内核中的检测器会拒绝加载引用了无效指针的字节码或者是以达到最大栈大小限制。循环也是不允许的（除非在编译时就知道是有常数上线的循环），字节码只能够调用一小部分指定的 eBPF 帮助函数。

使用 eBPF 提取内核更底层的特征，如内核函数调用、CPU 利用率等特征，网络流量、文件访问等特征
用机器学习算法进行分类检测。提高检测的效率，准确率，减少系统的资源消耗。

2、对通过ebpf拿到的一些数据做数据处理，拿到的数据中可能有些是对分类没有贡献，反而影响分类结果的特征，使用特征选择对拿到的数据，进行数据集降维，消除相关特征冗余。保证数据集的有效性和可靠性。

3、使用四种机器学习分类算法对数据集进行训练，定义评价指标，准确率、效率、误报率等，根据最终的分类结果，计算出评价指标。对比各种分类算法，得出最适合恶意软件检测的分类算法，最终进行分类检测。



####Linux下轻量级web服务器

该项目是Linux下C++轻量级Web服务器的实现。使用线程池 +非阻塞socket + epoll+事件处理的并发模型；使用状态机解析HTTP请求报文，⽀持解析GET和POST请求；访问服务器数据库实现web端用户注册、登录功能，可以请求服务器图片和视频文件；实现同步/异步日志系统，记录服务器运行状态。

**主要负责：**使用线程池 +非阻塞socket + epoll+事件处理的并发模型，采用单例模式和线程池，数据库连接池的方式，完成访问服务器数据库和日志系统的实现。



这个项目主要是疫情期间，应学校的课程要求，和同学做的一个项目。而且我们刚好也想提升下自己在C++方面的一个编程经验，增加些C++的项目经验，了解C++的项目流程。

项目是linux下C++轻量级web服务器的实现。项目的主要功能就是实现一个web端的多用户注册、登录，然后可以请求访问服务器上的图片的视频文件，实现并发处理。服务器可以记录各个用户登录，注册和访问的一些日志信息，并且使用压测软件webbeach，测试该服务器的负载性能。

由于项目中要实现多用户的并发访问，当进行并行的任务作业时，线程的建立与销毁的开销是阻碍性能的关键，因此项目中主要采用线程池，维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。避免线程的的创建和销毁带来的性能开销，避免大量的线程间因相互抢占资源导致的阻塞现象。采用非阻塞socket的和epoll并发模式，实现多用户的并发访问。非阻塞IO通过进程反复调用IO函数（多次系统调用，并马上返回）；在数据拷贝的过程中，进程是阻塞的；我们把一个SOCKET接口设置为非阻塞就是告诉内核，当所请求的I/O操作无法完成时，**不要将进程睡眠**，而是返回一个错误。使用epoll I/O复用，采用边缘触发模式，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，只有活跃可用的FD才会调用callback函数，即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关。

数据库连接使用单例模式，保证有唯一的连接对象。使用STL list容器实现数据库连接池，连接池的大小使用静态大小，使用互斥锁实现线程安全，在每次进行线程池操作之前进行加锁，操作完成之后解锁。同步/异步日志系统主要涉及了两个模块，一个是日志模块，一个是阻塞队列模块,其中加入阻塞队列模块主要是解决异步写入日志做准备.这里实现是使用的队列使**STL中的queue**为底层，使用单例模式确保全局只有唯一的一个对象，保证使用相同的队列。





**http解析：**

根据状态转移,通过主从状态机封装了http连接类。其中,主状态机在内部调用从状态机,从状态机将处理状态和数据传给主状态机。

客户端发出http连接请求，从状态机读取数据,更新自身状态和接收数据,传给主状态机

主状态机根据从状态机状态,更新自身状态,决定响应请求还是继续读取





#####线程池

**线程池:** 当进行并行的任务作业操作时，线程的建立与销毁的开销是，阻碍性能进步的关键，因此线程池，由此产生。使用多个线程，无限制循环等待队列，进行计算和操作。帮助快速降低和减少性能损耗。

线程池的组成

1. 线程池管理器：初始化和创建线程，启动和停止线程，调配任务；管理线程池
2. 工作线程：线程池中等待并执行分配的任务
3. 任务接口：添加任务的接口，以提供工作线程调度任务的执行。
4. 任务队列：用于存放没有处理的任务，提供一种缓冲机制，同时具有调度功能，高优先级的任务放在队列前面

线程池的优点

1）避免线程的创建和销毁带来的性能开销。
2）避免大量的线程间因互相抢占系统资源导致的阻塞现象。
3｝能够对线程进行简单的管理并提供定时执行、间隔执行等功能。



阻塞I/O

使用阻塞模式的套接字，开发网络程序比较简单，容易实现。当希望能够立即发送和接收数据，且处理的套接字数量比较少的情况下，使用阻塞模式来开发网络程序比较合适。

阻塞模式套接字的不足表现为，在大量建立好的套接字线程之间进行通信时比较困难。当使用“生产者-消费者”模型开发网络程序时，为每个套接字都分别分配一个读线程、一个处理数据线程和一个用于同步的事件，那么这样无疑加大系统的开销。其最大的缺点是当希望同时处理大量套接字时，将无从下手，其扩展性很差.

阻塞模式给网络编程带来了一个很大的问题，如在调用 send()的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。这给多客户机、多业务逻辑的网络编程带来了挑战。

多线程的服务器模型似乎完美的解决了为多个客户机提供问答服务的要求，但其实并不尽然。如果要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而线程与进程本身也更容易进入假死状态。

由此可能会考虑使用“**线程池**”或“**连接池**”。“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如apache，mysql数据库等。

非阻塞I/O

非阻塞IO通过进程反复调用IO函数（多次系统调用，并马上返回）；在数据拷贝的过程中，进程是阻塞的；我们把一个SOCKET接口设置为非阻塞就是告诉内核，当所请求的I/O操作无法完成时，**不要将进程睡眠**，而是返回一个错误。这样我们的I/O操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。在这个不断测试的过程中，会大量的占用CPU的时间。



**select：**

select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：

- 单个进程可监视的fd数量被限制，即能监听端口的大小有限。 一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.

- 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。

- 需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大

**poll：**

poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。

它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：

- 大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。                                                                                                                               
- poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。

**epoll:**

epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就需态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知

epoll的优点：

- 没有最大并发连接的限制，**能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；**
- **效率提升**，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；
  即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。
- 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。

**select、poll、epoll 区别总结：**

1、支持一个进程所能打开的最大连接数

| select | 单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32*32，同理64位机器上FD_SETSIZE为32*64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。 |
| ------ | ------------------------------------------------------------ |
| poll   | poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的 |
| epoll  | 虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接 |

2、FD剧增后带来的IO效率问题

| select | 因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。 |
| ------ | ------------------------------------------------------------ |
| poll   | 同上                                                         |
| epoll  | 因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。 |

3、 消息传递方式

| select | 内核需要将消息传递到用户空间，都需要内核拷贝动作 |
| ------ | ------------------------------------------------ |
| poll   | 同上                                             |
| epoll  | epoll通过内核和用户空间共享一块内存来实现的。    |

**总结：**

综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。

- 表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。

- select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善

**http解析：**

根据状态转移,通过主从状态机封装了http连接类。其中,主状态机在内部调用从状态机,从状态机将处理状态和数据传给主状态机

客户端发出http连接请求

从状态机读取数据,更新自身状态和接收数据,传给主状态机

主状态机根据从状态机状态,更新自身状态,决定响应请求还是继续读取



**服务器数据库模块:**数据库连接使用单例模式，保证有唯一的连接对象。使用STL list容器实现数据库连接池，连接池的大小使用静态大小，使用互斥锁实现线程安全，在每次进行线程池操作之前进行加锁，操作完成之后解锁。web端的一个用户注册和用户登录，以及请求服务器中的图片及视频文件，http都采用post方式。

**连接池**

对于一个简单的数据库应用，由于对于数据库的访问不是很频繁。这时可以简单地在需要访问数据库时，就新创建一个连接，用完后就关闭它，这样做也不会带来什么明显的性能上的开销。但是对于一个复杂的数据库应用。频繁的建立、关闭连接，会极大的减低系统的性能，因为对于连接的使用成了系统性能的瓶颈。

怎样解决：连接复用。通过建立一个数据库连接池以及一套连接使用管理策略，使得一个数据库连接可以得到高效、安全的复用，避免了数据库连接频繁建立、关闭的开销。就是共享连接资源，数据库连接池的基本原理是在内部对象池中维护一定数量的数据库连接，并对外暴露数据库连接获取和返回方法。

外部使用者可通过getConnection 方法获取连接，使用完毕后再通过releaseConnection 方法将连接返回，注意此时连接并没有关闭，而是由连接池管理器回收，并为下一次使用做好准备。

##### 数据库连接池技术带来的优势：

-  资源重用

由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增进了系统运行环境的平稳性（减少内存碎片以及数据库临时进程/线程的数量）。

- 更快的系统响应速度

数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间。

-  新的资源分配手段

对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接的配置，实现数据库连接池技术，几年钱也许还是个新鲜话题，对于目前的业务系统而言，如果设计中还没有考虑到连接池的应用，那么…….快在设计文档中加上这部分的内容吧。某一应用最大可用数据库连接数的限制，避免某一应用独占所有数据库资源。

- 统一的连接管理，避免数据库连接泄漏

在较为完备的数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用连接。从而避免了常规数据库连接操作中可能出现的资源泄漏。



**日志模块：**同步/异步日志系统主要涉及了两个模块，一个是日志模块，一个是阻塞队列模块,其中加入阻塞队列模块主要是解决异步写入日志做准备.这里实现是使用的队列使**STL中的queue**为底层，使用单例模式确保全局只有唯一的一个对象，保证使用相同的队列。



#### 数学建模大赛

利用现有的统计数据建立简化的气候模型和极端天气模型。建立的模型区别于复杂的专业气候模型，有利于非专业人士理解和认识全球气候变化的态势，解释极端天气现象的发生，寻找、求证影响气候变化的因素，从而增强人们气候变化的意识。

问题一：挖掘加拿大地区温度的时空变化趋势、探索海洋表面温度变化规律

对加拿大地区整体气候进行分析，将整个加拿大的城市按地区与气候分为七个类别，并从每个类型的地区气候中挑选一个城市作为样本，探索温度变化规律。

从美国国家海洋和大气管理局（NOAA）官网筛选下载海洋表面温度（SST）历史数据，处理数据后对海洋表面温度变化建立模型，探索温度变化的规律。

使用线性倾向估计进行建模分析，得出加拿大地区的温度随着时间的推移，在显著性的上升。全球海洋表面温度也在在显著上升。

问题二：建立一个刻画气候变化的模型对未来25年的气候变化进行预测，该模型考虑地球的吸热、散热以及海洋的温度变化等要素。

根据分析气候变化原因，我们总结了四个影响气候变化的因素：太阳总辐照度、地球长波辐射、海洋表面温度和大气中温室气体含量。确定这四个维度，收集前30年的历史数据，使用岭估计模型和ARMA模型预测未来25年的气候变化。

问题三：“极寒天气”是某地的天气现象，这种极端气象的出现，与气候变化有无关系？请建立相应的模型，并利用题目所提供的数据以及你能收集的数据说明：全球变暖和局地极寒现象的出现之间是否矛盾？

使用显著性检验，定性的说局部地区的极寒天气与当地的气候类型有很大关系。各地地理因素差异较大，所以各地气候呈现出各自的变化特征，单单某些地区的极寒天气出现，并不能否认全球平均气温上升的趋势。







####恶意软件检测系统研究

这个项目是一个学术研究性质的一个项目，主要是研究Android下的恶意软件的检测，判断一个APK文件是否是恶意软件还是正常软件。

项目主要分为三个大模块：第一个是特征提取

首先使用genymotion安卓模拟器运行apk文件，然后通过监控apk文件在内核下的行为，获取相应的行为特征。由于内核中的一些数据要拿到，比如内核函数的调用、CPU利用率计算的各个指标，网路流量等特征，可能需要写一个内核模块，插入到内核中，通过运行内核模块拿到相关数据。这样比较麻烦，耗时。这个项目采用了一种新技术ebpf技术。eBPF支持在用户态将C语言编写的一小段“内核代码”注入到内核中运行，注入时要先用llvm编译得到使用BPF指令集的elf文件，然后从elf文件中解析出可以注入内核的部分，最后用bpf_load_program方法完成注入。 用户态程序和注入到内核中的程序通过共用一个位于内核中`map`实现通信。为了防止注入的代码导致内核崩溃，eBPF会对注入的代码进行严格检查，拒绝不合格的代码的注入。BCC是一个python库，实现了map创建、代码编译、解析、注入等操作，使开发人员只需聚焦于用C语言开发要注入的内核代码。通过使用BCC工具获取相关特征。

第二个模块是：特征选择

这个模块主要是对所拿到的特征数据做个特征选择，因为拿到的数据过多，而且有些数据特征对分类没有作用，反而会影响分类训练的效果，所以要对数据集及逆行处理。主要是采用主成分分析和卡方检验对特征集进行数据处理，消除冗余特征，降低特征集的维度，增加特征集的可靠性和代表性。

第三个模块是：分类检测

将处理完的数据集导入weka工具中，采用不同的分类算法对数据集进行分类训练，这里采用十折交叉验证的方式来进行测试，就是将数据集分为10份，9份作为训练集，1份作为测试集，不断轮询。进行测试，通过分类指标来判断算法的检测效果，最终得出分类效果较好的算法，实现恶意软件的识别检测。



#### Linux下轻量级web服务器

该项目是Linux下C++轻量级Web服务器的实现。使用线程池 +非阻塞socket + epoll+事件处理的并发模型；使用状态机解析HTTP请求报文，⽀持解析GET和POST请求；访问服务器数据库实现web端用户注册、登录功能，可以请求服务器图片和视频文件；实现同步/异步日志系统，记录服务器运行状态。

**主要负责：**使用线程池 +非阻塞socket + epoll+事件处理的并发模型，采用单例模式和线程池，数据库连接池的方式，完成访问服务器数据库和日志系统的实现。



这个项目主要是疫情期间，应学校的课程要求，和同学做的一个项目。而且我们刚好也想提升下自己在C++方面的一个编程经验，增加些C++的项目经验，了解C++的项目流程。

项目是linux下C++轻量级web服务器的实现。项目的主要功能就是实现一个web端的多用户注册、登录，然后可以请求访问服务器上的图片的视频文件，实现并发处理。服务器可以记录各个用户登录，注册和访问的一些日志信息。

第一：由于项目中要实现多用户的并发访问，当进行并行的任务作业时，线程的建立与销毁的开销是阻碍性能的关键，因此项目中主要采用线程池，维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。避免线程的创建和销毁带来的性能开销，避免大量的线程间因相互抢占资源导致的阻塞现象。

第二：采用非阻塞socket的和epoll并发模式，实现多用户的并发访问。非阻塞IO通过进程多次系统调用，并马上返回，我们把一个SOCKET接口设置为非阻塞就是告诉内核，当所请求的I/O操作无法完成时，**不要将进程睡眠**，而是返回一个错误。此时进程就可以干其他事，减少不必要的时间等待。使用epoll I/O复用，采用边缘触发模式，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦这个fd就绪，内核就会采用回调机制激活fd。只有活跃的socket才会主动调用callback，不会采用轮询的方式去判断fd是否就绪，提升效率。

第三：HTTP解析，根据HTTP的状态转移，通过主从状态机封装了http的连接类。其中主状态机在内部调用从状态机，从状态机将处理状态和数据传给主状态机。客户端发出一个http连接请求，从状态机读取数据，更新自身状态和接受数据，传给主状态机。主状态机根据从状态机的状态，更新自身状态，决定响应请求还是继续读取。(这一部分不是很了解，参与的不是很多)

第四：数据库的连接实现。数据库连接使用单例模式，保证有唯一的连接对象。由于是多用户访问，可能会产生频繁的建立连接和关闭连接，这样会极大的减低系统的性能。采用连接服用技术，通过建立一个数据库连接池以及一些连接使用策略，使得一个数据库连接可以得到高效、安全的复用，避免了数据库连接频繁建立、关闭的开销。这个项目使用STL list容器实现数据库连接池，连接池的大小使用静态大小初始大小设置为10。在对数据库的相关操作中，使用互斥锁实现线程安全，在每次进行连接池操作之前进行加锁，操作完成之后解锁。

第五：日志系统。同步/异步日志系统主要涉及了两个模块，一个是日志模块，一个是阻塞队列模块,其中加入阻塞队列模块主要是为异步写入日志做准备。这里阻塞队列的实现是使用的**STL中的queue**为底层，使用单例模式确保全局只有唯一的一个对象，保证使用相同的队列。

最后使用webbeach压力测试软件，根据每秒钟响应请求数和每秒钟传输数据量，测试该服务器的负载性能，对应调整线程池大小和连接池大小。





**http解析：**

根据状态转移,通过主从状态机封装了http连接类。其中,主状态机在内部调用从状态机,从状态机将处理状态和数据传给主状态机。

客户端发出http连接请求，从状态机读取数据,更新自身状态和接收数据,传给主状态机

主状态机根据从状态机状态,更新自身状态,决定响应请求还是继续读取